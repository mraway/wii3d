<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Emgu.CV</name>
    </assembly>
    <members>
        <member name="T:Emgu.CV.Moment">
            <summary>
            A wrapper for the CvMoment structure
            </summary>
        </member>
        <member name="M:Emgu.CV.Moment.#ctor">
            <summary>
            Create a CvMoment structure
            </summary>
        </member>
        <member name="M:Emgu.CV.Moment.GetSpatialMoment(System.Int32,System.Int32)">
            <summary>
            The function GetSpatialMoment retrieves the spatial moment, which in case of image moments is defined as:
            Mx_order,y_order=sumx,y(I(x,y)晉x_order晊y_order)
            where I(x,y) is the intensity of the pixel (x, y). 
            </summary>
            <param name="x_order">x order of the retrieved moment, x_order &gt;= 0</param>
            <param name="y_order">y order of the retrieved moment, y_order &gt;= 0 and x_order + y_order &lt;= 3</param>
            <returns>the spatial moment</returns>
        </member>
        <member name="M:Emgu.CV.Moment.GetCentralMoment(System.Int32,System.Int32)">
            <summary>
            The function cvGetCentralMoment retrieves the central moment, which in case of image moments is defined as:
            ?x_order,y_order=sumx,y(I(x,y)?x-xc)x_order?y-yc)y_order),
            where xc=M10/M00, yc=M01/M00 - coordinates of the gravity center
            </summary>
            <param name="x_order">x order of the retrieved moment, x_order &gt;= 0.</param>
            <param name="y_order">y order of the retrieved moment, y_order &gt;= 0 and x_order + y_order &lt;= 3</param>
            <returns>The center moment</returns>
        </member>
        <member name="M:Emgu.CV.Moment.FreeUnmanagedObjects">
            <summary>
            Release the CvMoment strucutre and all the memory associate with it
            </summary>
        </member>
        <member name="P:Emgu.CV.Moment.Ptr">
            <summary>
            A pointer to the CvMoment structure
            </summary>
        </member>
        <member name="P:Emgu.CV.Moment.CvMoment">
            <summary>
            returns a managed CvMoment structure
            </summary>
        </member>
        <member name="P:Emgu.CV.Moment.CvHuMoment">
            <summary>
            Hu moments structure
            </summary>
        </member>
        <member name="P:Emgu.CV.Moment.GravityCenter">
            <summary>
            The Gravity Center of this Moment
            </summary>
        </member>
        <member name="T:Emgu.CV.Matrix`1">
            <summary> 
            The Matrix class that wrap around CvMat in OpenCV 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvArray`1">
            <summary>
            The Array class that wrap around CvArr in OpenCV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvArray`1._dataHandle">
            <summary>
            The pinned GcHandle to _array;
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.AllocateData(System.Int32,System.Int32)">
            <summary>
            Allocate data for the array
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of columns</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.DotProduct(Emgu.CV.CvArray{`0})">
            <summary>
            Calculates and returns the Euclidean dot product of two arrays.
            src1晄rc2 = sumI(src1(I)*src2(I))
            In case of multiple channel arrays the results for all channels are accumulated. In particular, cvDotProduct(a,a), where a is a complex vector, will return ||a||2. The function can process multi-dimensional arrays, row by row, layer by layer and so on.
            </summary>
            <param name="src2">The other Array to apply dot product with</param>
            <returns>src1晄rc2</returns>
        </member>
        <member name="M:Emgu.CV.CvArray`1.Copy(Emgu.CV.CvArray{`0})">
            <summary>
             Copy the current image to another one 
             </summary>
             <param name="dest"> The destination Array</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetValue(Emgu.CV.MCvScalar)">
            <summary> 
            Set the element of the Array to <paramref name="val"/>
            </summary>
            <param name="val"> The value to be set for each element of the Array </param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetValue(System.Double)">
            <summary> 
            Set the element of the Array to <paramref name="val"/>
            </summary>
            <param name="val"> The value to be set for each element of the Array </param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetValue(Emgu.CV.MCvScalar,Emgu.CV.CvArray{System.Byte})">
            <summary>
            Set the element of the Array to <paramref name="val"/>, using the specific <paramref name="mask"/>
            </summary>
            <param name="val">The value to be set</param>
            <param name="mask">The mask for the operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetValue(System.Double,Emgu.CV.CvArray{System.Byte})">
            <summary>
            Set the element of the Array to <paramref name="val"/>, using the specific <paramref name="mask"/>
            </summary>
            <param name="val">The value to be set</param>
            <param name="mask">The mask for the operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._RandUniform(System.UInt64,Emgu.CV.MCvScalar,Emgu.CV.MCvScalar)">
            <summary>
            Inplace fills Array with uniformly distributed random numbers
            </summary>
            <param name="seed">Seed for the random number generator</param>
            <param name="floorValue">the inclusive lower boundary of random numbers range</param>
            <param name="ceilingValue">the exclusive upper boundary of random numbers range</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._RandUniform(Emgu.CV.MCvScalar,Emgu.CV.MCvScalar)">
            <summary>
            Inplace fills Array with uniformly distributed random numbers
            </summary>
            <param name="floorValue">the inclusive lower boundary of random numbers range</param>
            <param name="ceilingValue">the exclusive upper boundary of random numbers range</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._RandNormal(System.UInt64,Emgu.CV.MCvScalar,Emgu.CV.MCvScalar)">
            <summary>
            Inplace fills Array with normally distributed random numbers
            </summary>
            <param name="seed">Seed for the random number generator</param>
            <param name="mean">the mean value of random numbers</param>
            <param name="std"> the standard deviation of random numbers</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._RandNormal(Emgu.CV.MCvScalar,Emgu.CV.MCvScalar)">
            <summary>
            Inplace fills Array with normally distributed random numbers
            </summary>
            <param name="mean">the mean value of random numbers</param>
            <param name="std"> the standard deviation of random numbers</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._SetIdentity(Emgu.CV.MCvScalar)">
            <summary>
            Initializs scaled identity matrix
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Mul(System.Double)">
            <summary>
            Inplace multiply elements of the Array by <paramref name="scale"/>
            </summary>
            <param name="scale">The scale to be multiplyed</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Mul(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace elementwise multiply the current Array with <paramref name="src2"/>
            </summary>
            <param name="src2">The other array to be elementwise multiplied with</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.FreeUnmanagedObjects">
            <summary>
            Free the _dataHandle if it is set
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Min(System.Double)">
            <summary>
            Inplace compute the elementwise minimum value 
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Min(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace elementwise minimize the current Array with <paramref name="src2"/>
            </summary>
            <param name="src2">The other array to be elementwise minimized with this array</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Max(System.Double)">
            <summary>
            Inplace compute the elementwise maximum value with <paramref name="val"/>
            </summary>
            <param name="val">The value to be compare with</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Max(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace elementwise maximize the current Array with <paramref name="src2"/>
            </summary>
            <param name="src2">The other array to be elementwise maximized with this array</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.EqualSize``1(Emgu.CV.CvArray{``0})">
            <summary>
            Determine if the size (width and height) of <i>this</i> Array
            equals the size of <paramref name="src2"/>
            </summary>
            <param name="src2"> The other Array to compare size with</param>
            <returns> True if the two Array has the same size</returns>
        </member>
        <member name="M:Emgu.CV.CvArray`1._And(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace And operation with <paramref name="src2"/>
            </summary>
            <param name="src2">The other array to perform And operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Or(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace Or operation with <paramref name="src2"/>
            </summary>
            <param name="src2">The other array to perform And operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Not">
            <summary> 
            Inplace compute the complement for all Array Elements
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetSchema">
            <summary>
            Get the xml schema
            </summary>
            <returns>the xml schema</returns>
        </member>
        <member name="M:Emgu.CV.CvArray`1.ReadXml(System.Xml.XmlReader)">
            <summary>
            Function to call when deserializing this object from XML
            </summary>
            <param name="reader">The xml reader</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Function to call when serializing this object to XML 
            </summary>
            <param name="writer">The xml writer</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serilization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.DeserializeObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime deserailization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Ptr">
            <summary> The pointer to the internal structure </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Width">
            <summary> 
             The width of the Array 
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Height">
            <summary> 
             The height of the Array 
             </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Rows">
            <summary>
            The number of rows for this array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Cols">
            <summary>
            The number of cols for this array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Bytes">
            <summary>
            Get or Set an Array of bytes that represent the data in this array
            </summary>
            <remarks> Should only be used for serialization &amp; deserialization</remarks>
        </member>
        <member name="P:Emgu.CV.CvArray`1.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.CompressedBytes">
            <summary>
            The binary data in compressed format
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Trace">
            <summary>
            sum of diagonal elements of the matrix 
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Norm">
            <summary> 
            The norm of this Array 
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor">
            <summary>
            The default constructor which allows Data to be set later on
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a matrix of the specific size
            </summary>
            <param name="rows">The number of rows (<b>height</b>)</param>
            <param name="cols">The number of cols (<b>width</b>)</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(`0[0:,0:])">
            <summary> Create a matrix using the specific <paramref>data</paramref></summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.BlankClone">
            <summary>
            Return a matrix of the same size with all elements equals 0
            </summary>
            <returns>A matrix of the same size with all elements equals 0</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Transpose">
            <summary> Returns the transpose of this matrix</summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.AllocateData(System.Int32,System.Int32)">
            <summary>
            Allocate data for the array
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of columns</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.FreeUnmanagedObjects">
            <summary>
            Release the matrix and all the memory associate with it
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Cmp(Emgu.CV.Matrix{`0},Emgu.CV.CvEnum.CMP_TYPE)">
            <summary>
            This function compare the current image with <paramref name="mat2"/> and returns the comparison mask
            </summary>
            <param name="mat2">the other matrix to compare with</param>
            <param name="type">comparison type</param>
            <returns>The comparison mask</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Equals(Emgu.CV.Matrix{`0})">
            <summary>
            Return true if every element of this matrix equals elements in <paramref name="mat2"/>
            </summary>
            <param name="mat2">The other matrix to compare with</param>
            <returns>true if every element of this matrix equals elements in <paramref name="mat2"/></returns>
        </member>
        <member name="P:Emgu.CV.Matrix`1.CvDepth">
            <summary> Get the depth representation for openCV</summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Width">
            <summary> The Width (Number of rows) of the Matrix </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Height">
            <summary> The Height (Number of columns) of the Matrix </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Data">
            <summary>
            Get or Set the data for this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.CvMat">
            <summary>
            The MCvMat structure format  
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Det">
            <summary>
            The function cvDet returns determinant of the square matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Sum">
            <summary>
            Return the sum of the elements in this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Item(System.Int32,System.Int32)">
            <summary>
            Get or Set the value in the specific <paramref name="row"/> and <paramref name="col"/>
            </summary>
            <param name="row">the row of the element</param>
            <param name="col">the col of the element</param>
            <returns></returns>
        </member>
        <member name="T:Emgu.CV.DuplexCaptureCallback">
            <summary>
            A simple implementation of the IDuplexCaptureCallback interface
            </summary>
        </member>
        <member name="T:Emgu.CV.IDuplexCaptureCallback">
            <summary>
            The interface for DuplexCaptureCallback
            </summary>
        </member>
        <member name="M:Emgu.CV.IDuplexCaptureCallback.ReceiveFrame(Emgu.CV.Image{Emgu.CV.Bgr,System.Byte})">
            <summary>
            Function to call when an image is received
            </summary>
            <param name="img">The image received</param>
        </member>
        <member name="M:Emgu.CV.DuplexCaptureCallback.#ctor">
            <summary>
            Construct a DuplexCaptureCallback
            </summary>
        </member>
        <member name="M:Emgu.CV.DuplexCaptureCallback.ReceiveFrame(Emgu.CV.Image{Emgu.CV.Bgr,System.Byte})">
            <summary>
            Function to call when an image is received.
            </summary>
        </member>
        <member name="P:Emgu.CV.DuplexCaptureCallback.CapturedImage">
            <summary>
            Get the image that has been captured.
            </summary>
        </member>
        <member name="E:Emgu.CV.DuplexCaptureCallback.onFrameReceived">
            <summary>
            Handler events when image is received.
            </summary>
        </member>
        <member name="T:Emgu.CV.MCvTermCriteria">
            <summary>
            Managed structure equivalent to CvTermCriteria
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvTermCriteria.type">
            <summary>
            CV_TERMCRIT value
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvTermCriteria.max_iter">
            <summary>
            Maximum iteration
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvTermCriteria.epsilon">
            <summary>
            Epsilon
            </summary>
        </member>
        <member name="M:Emgu.CV.MCvTermCriteria.#ctor(System.Int32)">
            <summary>
            Create the termination criteria using the constrain of maximum iteration
            </summary>
            <param name="maxIteration">The maximum number of iteration allowed</param>
        </member>
        <member name="M:Emgu.CV.MCvTermCriteria.#ctor(System.Double)">
            <summary>
            Create the termination Criteria using only the constrain of epsilon
            </summary>
            <param name="eps"> The epsilon value</param>
        </member>
        <member name="M:Emgu.CV.MCvTermCriteria.#ctor(System.Int32,System.Double)">
            <summary>
            Create the termination criteria using the constrain of maximum iteration as well as epsilon
            </summary>
            <param name="maxIteration">The maximum number of iteration allowed</param>
            <param name="eps">The epsilon value</param>
        </member>
        <member name="T:Emgu.CV.UI.ImageBox">
            <summary>
            An image box is a user control that is similar to picture box, but display Emgu CV IImage and provides enhenced functionalities.
            </summary>
        </member>
        <member name="F:Emgu.CV.UI.ImageBox._counterStartTime">
            <summary>
            one of the parameters used for caculating the frame rate
            </summary>
        </member>
        <member name="F:Emgu.CV.UI.ImageBox._imageReceivedSinceCounterStart">
            <summary>
            one of the parameters used for caculating the frame rate
            </summary>
        </member>
        <member name="M:Emgu.CV.UI.ImageBox.#ctor">
            <summary>
            Create a ImageBox
            </summary>
        </member>
        <member name="M:Emgu.CV.UI.ImageBox.PushOperation(Emgu.Reflection.Operation{Emgu.CV.IImage})">
            <summary>
            Push the specific operation onto the stack
            </summary>
            <param name="operation">The operation to be pushed onto the stack</param>
        </member>
        <member name="M:Emgu.CV.UI.ImageBox.ClearOperation">
            <summary>
            Remove all the operations from the stack
            </summary>
        </member>
        <member name="M:Emgu.CV.UI.ImageBox.pictureBox_MouseMove(System.Object,System.Windows.Forms.MouseEventArgs)">
            <summary>
            Used for tracking the mouse position on the image
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="F:Emgu.CV.UI.ImageBox.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:Emgu.CV.UI.ImageBox.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Emgu.CV.UI.ImageBox.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="P:Emgu.CV.UI.ImageBox.Image">
            <summary>
            Set the image for this image box
            </summary>
        </member>
        <member name="T:Emgu.CV.Hsv">
            <summary> 
            Defines a HSV (Hue Satuation Value) color
            </summary>
        </member>
        <member name="T:Emgu.CV.ColorType">
            <summary>
             A color type
            </summary>
        </member>
        <member name="T:Emgu.CV.Point`1">
            <summary> A multi dimension point</summary>
            <typeparam name="T"> The type of value for this point</typeparam>
        </member>
        <member name="F:Emgu.CV.Point`1._coordinate">
            <summary> The internal representation of this point as an array</summary>
        </member>
        <member name="M:Emgu.CV.Point`1.#ctor">
            <summary> Create a default point of 0 dimension</summary>
        </member>
        <member name="M:Emgu.CV.Point`1.#ctor(System.Int32)">
            <summary> Create a point of the specific dimension</summary>
            <param name="dimension">The dimension of this point</param>
        </member>
        <member name="M:Emgu.CV.Point`1.#ctor(`0[])">
            <summary> Create a point using the specific data</summary>
            <param name="data"> The array of data that define this point</param>
        </member>
        <member name="M:Emgu.CV.Point`1.Convert``2(Emgu.CV.Point{``0},Emgu.Utils.Func{`0,``0,``1})">
            <summary>
            Perform a generic operation between two points and return the result
            </summary>
            <typeparam name="T2">The type of the second point</typeparam>
            <typeparam name="T3">The type of the resulting point</typeparam>
            <param name="p2">The second point to apply generic operation</param>
            <param name="convertor">The generic operator</param>
            <returns>The result of the generic operation</returns>
        </member>
        <member name="M:Emgu.CV.Point`1._Convert``1(Emgu.CV.Point{``0},Emgu.Utils.Func{`0,``0,`0})">
            <summary>
            Perform a generic operation between two points and store the result in the first point
            </summary>
            <typeparam name="T2">The type of the second point</typeparam>
            <param name="p2">The second point to apply generic operation</param>
            <param name="convertor">The generic operator</param>
        </member>
        <member name="M:Emgu.CV.Point`1.Sub``1(Emgu.CV.Point{``0})">
            <summary> 
            substract the current point with another point and returns the result
            </summary>
            <seealso cref="M:Emgu.CV.Point`1.op_Subtraction(Emgu.CV.Point{`0},Emgu.CV.Point{`0})"></seealso>
            <param name="other"> The other point to be added to <i>this</i></param> 
            <returns>The sum of the two point</returns>
        </member>
        <member name="M:Emgu.CV.Point`1._Sub``1(Emgu.CV.Point{``0})">
            <summary>
            Subtract <paramref name="other"/> from the current point
            </summary>
            <typeparam name="T2">The type of the point to be substracted</typeparam>
            <param name="other">The point to be substracted</param>
        </member>
        <member name="M:Emgu.CV.Point`1.op_Subtraction(Emgu.CV.Point{`0},Emgu.CV.Point{`0})">
            <summary>
            Subtract the 2nd point from the 1st point and returns the result
            </summary>
            <param name="p1"> The point to subtract value from </param>
            <param name="p2"> The value to be subtracted from p1 </param>
        </member>
        <member name="M:Emgu.CV.Point`1.Add``1(Emgu.CV.Point{``0})">
            <summary> Sum the current point with another point and returns the result</summary>
            <seealso cref="M:Emgu.CV.Point`1.op_Addition(Emgu.CV.Point{`0},Emgu.CV.Point{`0})"></seealso>
        </member>
        <member name="M:Emgu.CV.Point`1._Add``1(Emgu.CV.Point{``0})">
            <summary>
            An the other point to the current point
            </summary>
            <param name="other">The point to be added to this</param>
        </member>
        <member name="M:Emgu.CV.Point`1.op_Addition(Emgu.CV.Point{`0},Emgu.CV.Point{`0})">
            <summary>
            Add the 2nd point from the 1st point and returns the result
            </summary>
            <param name="p1">The point to be added</param>
            <param name="p2">The point to be added</param>
            <returns>The sum of the points</returns>
        </member>
        <member name="M:Emgu.CV.Point`1.Convert``1">
            <summary> Convert this point to the specific type</summary>
            <returns> An equavailent point of the specific type</returns> 
        </member>
        <member name="M:Emgu.CV.Point`1.Resize(System.Int32)">
            <summary>
            Resize the current point to the specific size, 
            if the new size is smaller, perform a truncation,
            if the new size is larger, the rest of the space is filled with default value
            </summary>
            <param name="size">The new size of the point</param>
            <returns>The resized point</returns>
        </member>
        <member name="M:Emgu.CV.Point`1.Equals(Emgu.CV.Point{`0})">
            <summary>
            Compare if the two point have equal dimension and value, if so, return true, otherwise, false
            </summary>
            <param name="p2">The other point to compare with</param>
            <returns>true if the two points equal, false otherwise</returns>
        </member>
        <member name="P:Emgu.CV.Point`1.Coordinate">
            <summary> The array representation of this point, <remark>warning: changing the value of this array also change the position of the point </remark></summary>
        </member>
        <member name="P:Emgu.CV.Point`1.Dimension">
            <summary> The dimension of this point</summary>
        </member>
        <member name="P:Emgu.CV.Point`1.Norm">
            <summary> The norm of this point. e.g. sqrt(X^2 + Y^2 + ...) </summary>
        </member>
        <member name="P:Emgu.CV.Point`1.Normalized">
            <summary> Return a normalized point (aka. the direction) </summary>  
        </member>
        <member name="P:Emgu.CV.Point`1.Item(System.Int32)">
            <summary> Return the specific element in this point</summary>
        </member>
        <member name="M:Emgu.CV.ColorType.#ctor(System.Int32)">
            <summary>
            Create a color type of certain dimension
            </summary>
            <param name="dimension"></param>
        </member>
        <member name="P:Emgu.CV.ColorType.MCvScalar">
            <summary>
            The equivalent of MCvScalar value
            </summary>
        </member>
        <member name="P:Emgu.CV.ColorType.CvScalar">
            <summary>
            To be removed in the next version
            </summary>
        </member>
        <member name="M:Emgu.CV.Hsv.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a HSV color using the specific values</summary>
            <param name="hue"> The hue value for this color ( 0 &lt; hue &lt; 180 )  </param>
            <param name="satuation"> The satuation value for this color </param>
            <param name="value"> The value for this color </param>
        </member>
        <member name="M:Emgu.CV.Hsv.#ctor">
            <summary> Create a HSV color using the default values (0.0, 0.0, 0.0)</summary>
        </member>
        <member name="P:Emgu.CV.Hsv.H">
            <summary> The intensity of the hue color channel ( 0 &lt; hue &lt; 180 ) </summary>
        </member>
        <member name="P:Emgu.CV.Hsv.S">
            <summary> The intensity of the satuation color channel </summary>
        </member>
        <member name="P:Emgu.CV.Hsv.V">
            <summary> The intensity of the value color channel </summary>
        </member>
        <member name="T:Emgu.CV.CameraCalibration.CameraCalibration">
            <summary>
            Functions used form camera calibration
            </summary>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.CameraCalibration.FindExtrinsicCameraParams2(Emgu.CV.Point3D{System.Single}[],Emgu.CV.Point2D{System.Single}[],Emgu.CV.CameraCalibration.IntrinsicCameraParameters)">
            <summary>
            The function cvFindExtrinsicCameraParams2 estimates extrinsic camera parameters using known intrinsic parameters and and extrinsic parameters for each view. The coordinates of 3D object points and their correspondent 2D projections must be specified. This function also minimizes back-projection error. 
            </summary>
            <param name="objectPoints">The array of object points</param>
            <param name="imagePoints">The array of corresponding image points</param>
            <param name="intrin">The intrinsic parameters</param>
            <returns>the extrinsic parameters</returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.CameraCalibration.CalibrateCamera2(Emgu.CV.Point3D{System.Single}[],Emgu.CV.Point2D{System.Single}[],Emgu.CV.Matrix{System.Byte},Emgu.CV.MCvSize,Emgu.CV.CameraCalibration.IntrinsicCameraParameters@,Emgu.CV.CameraCalibration.ExtrinsicCameraParameters@,System.Int32)">
            <summary>
            The function cvCalibrateCamera2 Finds intrinsic and extrinsic camera parameters using calibration pattern 
            only one view is allowed
            </summary>
            <param name="objectPoints">The array of object points</param>
            <param name="imagePoints">The array of corresponding image points</param>
            <param name="pointCounts">The array containing numbers of points in each particular view, 1xM or Mx1, where M is the number of a scene views.</param>
            <param name="imageSize">Size of the image, used only to initialize intrinsic camera matrix.</param>
            <param name="extrin">The extrinsic parameters</param>
            <param name="intrin">The intrinsic parameters</param>
            <param name="flags">Different flags, may be 0 or combination of the following values:
            CV_CALIB_USE_INTRINSIC_GUESS(0x01) - intrinsic_matrix contains valid initial values of fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image center (image_size is used here), and focal distances are computed in some least-squares fashion. Note, that if intrinsic parameters are known, there is no need to use this function. Use cvFindExtrinsicCameraParams2 instead.
            CV_CALIB_FIX_PRINCIPAL_POINT(0x04) - The principal point is not changed during the global optimization, it stays at the center and at the other location specified (when CV_CALIB_USE_INTRINSIC_GUESS is set as well).
            CV_CALIB_FIX_ASPECT_RATIO(0x02) - The optimization procedure consider only one of fx and fy as independent variable and keeps the aspect ratio fx/fy the same as it was set initially in intrinsic_matrix. In this case the actual initial values of (fx, fy) are either taken from the matrix (when CV_CALIB_USE_INTRINSIC_GUESS is set) or estimated somehow (in the latter case fx, fy may be set to arbitrary values, only their ratio is used).
            CV_CALIB_ZERO_TANGENT_DIST(0x08) - Tangential distortion coefficients are set to zeros and do not change during the optimization.</param>
            <returns>results are in extrinsic and intrinsic parameters</returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.CameraCalibration.Undistort2``2(Emgu.CV.Image{``0,``1},Emgu.CV.CameraCalibration.IntrinsicCameraParameters)">
            <summary>
            The function Undistort2 transforms the image to compensate radial and tangential lens distortion. The camera matrix and distortion parameters can be determined using cvCalibrateCamera2. For every pixel in the output image the function computes coordinates of the corresponding location in the input image using the formulae in the section beginning. Then, the pixel value is computed using bilinear interpolation. If the resolution of images is different from what was used at the calibration stage, fx, fy, cx and cy need to be adjusted appropriately, while the distortion coefficients remain the same
            </summary>
            <typeparam name="C">The color type of the image</typeparam>
            <typeparam name="D">The depth of the image</typeparam>
            <param name="src">the distorted image</param>
            <param name="intrin">the intrinsic camera parameters</param>
            <returns>the corected image</returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.CameraCalibration.ProjectPoints2(Emgu.CV.Point3D{System.Single}[],Emgu.CV.CameraCalibration.ExtrinsicCameraParameters,Emgu.CV.CameraCalibration.IntrinsicCameraParameters,Emgu.CV.Matrix{System.Single}[])">
            <summary>
            <para>The function cvProjectPoints2 computes projections of 3D points to the image plane given intrinsic and extrinsic camera parameters. Optionally, the function computes jacobians - matrices of partial derivatives of image points as functions of all the input parameters w.r.t. the particular parameters, intrinsic and/or extrinsic. The jacobians are used during the global optimization in cvCalibrateCamera2 and cvFindExtrinsicCameraParams2. The function itself is also used to compute back-projection error for with current intrinsic and extrinsic parameters.</para>
            <para>Note, that with intrinsic and/or extrinsic parameters set to special values, the function can be used to compute just extrinsic transformation or just intrinsic transformation (i.e. distortion of a sparse set of points) </para> 
            </summary>
            <param name="objectPoints">The array of object points, 3xN or Nx3, where N is the number of points in the view</param>
            <param name="extrin">extrinsic parameters</param>
            <param name="intrin">intrinsic parameters</param>
            <param name="mats">Optional matrix supplied in the following order: dpdrot, dpdt, dpdf, dpdc, dpddist</param>
            <returns>A Nx2 matrix of 2D points</returns>
        </member>
        <member name="T:Emgu.CV.HaarCascade">
            <summary> The HaarCascade class for object detection</summary>
        </member>
        <member name="M:Emgu.CV.HaarCascade.#ctor(System.String)">
            <summary> Create a HaarCascade object from the specific file</summary>
            <param name="fileName"> The name of the file that contains the HaarCascade object</param>
        </member>
        <member name="M:Emgu.CV.HaarCascade.FreeUnmanagedObjects">
            <summary>
            Release the HaarCascade Object and all the memory associate with it
            </summary>
        </member>
        <member name="T:Emgu.CV.Ellipse`1">
            <summary>
            An ellipse
            </summary>
        </member>
        <member name="T:Emgu.CV.Box2D`1">
            <summary>
             A rotated rectangle box
            </summary>
        </member>
        <member name="T:Emgu.CV.Rectangle`1">
            <summary> A rectangle </summary>
        </member>
        <member name="T:Emgu.CV.Point2D`1">
            <summary> A two dimensional point </summary>
            <typeparam name="T"> The type of value for this 2D point</typeparam>
        </member>
        <member name="M:Emgu.CV.Point2D`1.#ctor">
            <summary> Create a 2D point located in the origin</summary>
        </member>
        <member name="M:Emgu.CV.Point2D`1.#ctor(`0,`0)">
            <summary> Create a 2D point of the specific location</summary>
            <param name="x"> The x value of this point</param>
            <param name="y"> The y value of this point</param>
        </member>
        <member name="M:Emgu.CV.Point2D`1.#ctor(`0[])">
            <summary> Create a 2D point from a array of size 2</summary>
            <param name="data"> An array of size 2</param>
        </member>
        <member name="M:Emgu.CV.Point2D`1.Convert``1">
            <summary> Convert this 2D point to the specific format</summary>
            <returns> An equavailent 2D point of the specific format</returns> 
        </member>
        <member name="P:Emgu.CV.Point2D`1.X">
            <summary> The x value of this point</summary>
        </member>
        <member name="P:Emgu.CV.Point2D`1.Y">
            <summary> The y value of this point</summary>
        </member>
        <member name="P:Emgu.CV.Point2D`1.PointRadianAngle">
            <summary> The angle between the direction of this point and the x-axis, in radian</summary>
        </member>
        <member name="P:Emgu.CV.Point2D`1.PointDegreeAngle">
            <summary> The angle between the direction of this point and the x-axis, in degree</summary>
        </member>
        <member name="P:Emgu.CV.Point2D`1.CvPoint">
            <summary>
            The CvPoint representation of th is 2D point
            </summary>
        </member>
        <member name="M:Emgu.CV.Rectangle`1.#ctor">
            <summary> Create a rectangle with default values </summary>
        </member>
        <member name="M:Emgu.CV.Rectangle`1.#ctor(Emgu.CV.Point2D{`0},Emgu.CV.Point2D{`0})">
            <summary> Create a rectangle with the specific center, with and height</summary>
            <param name="center"> The center of the rectangle</param>
            <param name="size"> The size of the rectangle </param>
        </member>
        <member name="M:Emgu.CV.Rectangle`1.#ctor(`0,`0,`0,`0)">
            <summary> Create a rectangle with the specific left, right, top bottom corrdinates</summary>
        </member>
        <member name="M:Emgu.CV.Rectangle`1.#ctor(Emgu.CV.MCvRect)">
            <summary> Create a rectangle from a CvRect structure </summary>
        </member>
        <member name="M:Emgu.CV.Rectangle`1.Equals(Emgu.CV.Rectangle{`0})">
            <summary>
            Compare two rectangle, if equal, return true, otherwise return false
            </summary>
            <param name="rec">the other rectangle to compare with</param>
            <returns>true if the two rectangle equals, false otherwise</returns>
        </member>
        <member name="P:Emgu.CV.Rectangle`1.Left">
            <summary>
            The left most coordinate
            </summary>
        </member>
        <member name="P:Emgu.CV.Rectangle`1.Right">
            <summary>
            The right most coordinate
            </summary>
        </member>
        <member name="P:Emgu.CV.Rectangle`1.Top">
            <summary>
            The top most coordinate
            </summary>
        </member>
        <member name="P:Emgu.CV.Rectangle`1.Bottom">
            <summary>
            The bottom most coordinate
            </summary>
        </member>
        <member name="P:Emgu.CV.Rectangle`1.Size">
            <summary>
            The Size (width and height) of this rectangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Rectangle`1.Center">
            <summary> The center of the rectangle</summary>
        </member>
        <member name="P:Emgu.CV.Rectangle`1.Width">
            <summary> The width of the rectangle </summary>
        </member>
        <member name="P:Emgu.CV.Rectangle`1.Height">
            <summary> The height of the rectangle </summary> 
        </member>
        <member name="P:Emgu.CV.Rectangle`1.TopLeft">
            <summary> The top left corner of the rectangle</summary>
        </member>
        <member name="P:Emgu.CV.Rectangle`1.TopRight">
            <summary> The top right corner of the rectangle</summary>
        </member>
        <member name="P:Emgu.CV.Rectangle`1.BottomLeft">
            <summary> The bottom left corner of the rectangle</summary>
        </member>
        <member name="P:Emgu.CV.Rectangle`1.BottomRight">
            <summary> The bottom right corner of the rectangle</summary>
        </member>
        <member name="P:Emgu.CV.Rectangle`1.Area">
            <summary> The area of the rectangle </summary>
        </member>
        <member name="P:Emgu.CV.Rectangle`1.MCvRect">
            <summary> The CvRect representation of this rectangle </summary>
        </member>
        <member name="F:Emgu.CV.Box2D`1._angle">
            <summary>
            The rotation angle of the rectangle in radians
            </summary>
        </member>
        <member name="M:Emgu.CV.Box2D`1.#ctor">
            <summary> 
            Create an rotated rectangle with default parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.Box2D`1.Equals(Emgu.CV.Box2D{`0})">
            <summary>
            Compare this box with <paramref name="box2"/>
            </summary>
            <param name="box2">The other box to be compared</param>
            <returns>true if the two boxes equals</returns>
        </member>
        <member name="M:Emgu.CV.Box2D`1.#ctor(Emgu.CV.Point2D{`0},Emgu.CV.Point2D{`0},System.Double)">
            <summary>
            Create an rotated rectangle with specific parameters
            </summary>
            <param name="center"> The center of the rectangle</param>
            <param name="size"> The size of the rectangle</param>
            <param name="angle"> The rotation angle in radian for the rectangle</param>
        </member>
        <member name="P:Emgu.CV.Box2D`1.RadianAngle">
            <summary> The rotation angle for this box in radian</summary>
        </member>
        <member name="P:Emgu.CV.Box2D`1.DegreeAngle">
            <summary> The rotation angle for this box in radian</summary>
        </member>
        <member name="P:Emgu.CV.Box2D`1.MCvBox2D">
            <summary> The CvBox2D representation of this rectangle </summary>
        </member>
        <member name="M:Emgu.CV.Ellipse`1.#ctor">
            <summary> 
            Create an ellipse with default parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.Ellipse`1.#ctor(Emgu.CV.Point2D{`0},Emgu.CV.Point2D{`0},System.Double)">
            <summary>
            Create an ellipse with specific parameters
            </summary>
            <param name="center"> The center of the ellipse</param>
            <param name="size"> The width and height of the ellipse</param>
            <param name="angle"> The rotation angle in radian for the ellipse</param>
        </member>
        <member name="T:Emgu.CV.CvInvoke">
            <summary>
            Library to invoke OpenCV functions
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.#cctor">
            <summary>
            Static Constructor to setup opencv environment
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.DefaultCvErrorHandler">
            <summary>
            The default Exception callback to handle Error thrown by OpenCV
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvErrorHandler(System.Int32,System.String,System.String,System.String,System.Int32,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the souce where error is encountered</param>
            <param name="userData">Arbitrary pointer that is transparetly passed to the error handler.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRedirectError(Emgu.CV.CvInvoke.CvErrorCallback,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvRedirectError sets a new error handler that can be one of standard handlers or a custom handler that has the certain interface. The handler takes the same parameters as cvError function. If the handler returns non-zero value, the program is terminated, otherwise, it continues. The error handler may check the current error mode with cvGetErrMode to make a decision.
            </summary>
            <param name="error_handler">The new error_handler</param>
            <param name="userdata">Arbitrary pointer that is transparetly passed to the error handler.</param>
            <param name="prev_userdata">Pointer to the previously assigned user data pointer.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetErrMode(System.Int32)">
            <summary>
            The function cvSetErrMode sets the specified error mode.
            </summary>
            <param name="errorMode">The error mode</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetErrMode">
            <summary>
            The function cvGetErrMode returns the current error mode
            </summary>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetErrStatus">
            <summary>
            The function cvGetErrStatus returns the current error status - the value set with the last cvSetErrStatus call. Note, that in Leaf mode the program terminates immediately after error occured, so to always get control after the function call, one should call cvSetErrMode and set Parent or Silent error mode.
            </summary>
            <returns>the current error status</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetErrStatus(Emgu.CV.CvEnum.ERROR_CODES)">
            <summary>
            The function cvSetErrStatus sets the error status to the specified value. Mostly, the function is used to reset the error status (set to it CV_StsOk) to recover after error. In other cases it is more natural to call cvError or CV_ERROR.
            </summary>
            <param name="code">The error status.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvNot(System.IntPtr,System.IntPtr)">
            <summary>
            The function Not inverses every bit of every array element:
            </summary>
            <param name="src">The source array</param>
            <param name="des">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMax(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvMax calculates per-element maximum of two arrays:
            dst(I)=max(src1(I), src2(I))
            All the arrays must have a single channel, the same data type and the same size (or ROI size).
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array. </param>
            <param name="dst">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMaxS(System.IntPtr,System.Double,System.IntPtr)">
            <summary>
            <para>The function cvMaxS calculates per-element maximum of array and scalar:</para>
            <para>dst(I)=max(src(I), value)</para>
            <para>All the arrays must have a single channel, the same data type and the same size (or ROI size).</para>
            </summary>
            <param name="src">The first source array</param>
            <param name="value">The scalar value</param>
            <param name="dst">The destination array. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCountNonZero(System.IntPtr)">
            <summary>
            The function cvCountNonZero returns the number of non-zero elements in arr:
            result = sumI arr(I)!=0
            In case of IplImage both ROI and COI are supported.
            </summary>
            <param name="arr">The image</param>
            <returns>the number of non-zero elements in image</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMin(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvMin calculates per-element minimum of two arrays:
            dst(I)=min(src1(I),src2(I))
            All the arrays must have a single channel, the same data type and the same size (or ROI size).
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMinS(System.IntPtr,System.Double,System.IntPtr)">
            <summary>
            The function cvMinS calculates minimum of array and scalar:
            dst(I)=min(src(I), value)
            All the arrays must have a single channel, the same data type and the same size (or ROI size).
            </summary>
            <param name="src">The first source array</param>
            <param name="value">The scalar value</param>
            <param name="dst">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAdd(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvAdd adds one array to another one:
            dst(I)=src1(I)+src2(I) if mask(I)!=0All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array.</param>
            <param name="src2">The second source array.</param>
            <param name="dst">The destination array.</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAddS(System.IntPtr,Emgu.CV.MCvScalar,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvAddS adds scalar <paramref name="value"/> to every element in the source array src1 and stores the result in dst
            dst(I)=src(I)+value if mask(I)!=0
            All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </summary>
            <param name="src">The source array.</param>
            <param name="value">Added scalar.</param>
            <param name="dst">The destination array.</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSub(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvSub subtracts one array from another one:
            dst(I)=src1(I)-src2(I) if mask(I)!=0
            All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSubS(System.IntPtr,Emgu.CV.MCvScalar,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvSubS subtracts a scalar from every element of the source array:
            dst(I)=src(I)-value if mask(I)!=0
            All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </summary>
            <param name="src">The source array</param>
            <param name="value">Subtracted scalar</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSubRS(System.IntPtr,Emgu.CV.MCvScalar,System.IntPtr,System.IntPtr)">
             <summary>
             The function cvSubRS subtracts every element of source array from a scalar:
            dst(I)=value-src(I) if mask(I)!=0
            All the arrays must have the same type, except the mask, and the same size (or ROI size)
             </summary>
             <param name="src">The source array</param>
             <param name="value">Subtracted scalar</param>
             <param name="dst">The destination array</param>
             <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDiv(System.IntPtr,System.IntPtr,System.IntPtr,System.Double)">
            <summary>
            The function cvDiv divides one array by another:
            dst(I)=scale•src1(I)/src2(I), if src1!=NULL
            dst(I)=scale/src2(I),      if src1=NULL
            All the arrays must have the same type, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array. If the pointer is NULL, the array is assumed to be all 1’s. </param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="scale">Optional scale factor </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMul(System.IntPtr,System.IntPtr,System.IntPtr,System.Double)">
            <summary>
            The function cvMul calculates per-element product of two arrays:
            dst(I)=scale•src1(I)•src2(I)
            All the arrays must have the same type, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array. </param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="scale">Optional scale factor</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAnd(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvAnd calculates per-element bit-wise logical conjunction of two arrays:
            dst(I)=src1(I) &amp; src2(I) if mask(I)!=0
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAndS(System.IntPtr,Emgu.CV.MCvScalar,System.IntPtr,System.IntPtr)">
            <summary>
            The function AndS calculates per-element bit-wise conjunction of array and scalar:
            dst(I)=src(I)&amp;value if mask(I)!=0
            Prior to the actual operation the scalar is converted to the same type as the arrays. In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src">The source array</param>
            <param name="value">Scalar to use in the operation</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvOr(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvOr calculates per-element bit-wise disjunction of two arrays:
            dst(I)=src1(I)|src2(I)
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvOrS(System.IntPtr,Emgu.CV.MCvScalar,System.IntPtr,System.IntPtr)">
            <summary>
            The function OrS calculates per-element bit-wise disjunction of array and scalar:
            dst(I)=src(I)|value if mask(I)!=0
            Prior to the actual operation the scalar is converted to the same type as the arrays. In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src">The source array</param>
            <param name="value">Scalar to use in the operation</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvXor(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvXor calculates per-element bit-wise logical conjunction of two arrays:
            dst(I)=src1(I)^src2(I) if mask(I)!=0
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">mask, 8-bit single channel array; specifies elements of destination array to be changed.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvXorS(System.IntPtr,Emgu.CV.MCvScalar,System.IntPtr,System.IntPtr)">
            <summary>
            The function XorS calculates per-element bit-wise conjunction of array and scalar:
            dst(I)=src(I)^value if mask(I)!=0
            Prior to the actual operation the scalar is converted to the same type as the arrays. In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src">The source array</param>
            <param name="value">Scalar to use in the operation</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSet(System.IntPtr,Emgu.CV.MCvScalar,System.IntPtr)">
             <summary>
             The function cvSet copies scalar value to every selected element of the destination array:
            arr(I)=value if mask(I)!=0
            If array arr is of IplImage type, then is ROI used, but COI must not be set
             </summary>
             <param name="arr">The destination array</param>
             <param name="value">Fill value</param>
             <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvLog(System.IntPtr,System.IntPtr)">
            <summary>
            The function cvLog calculates natural logarithm of absolute value of every element of input array:
            dst(I)=log(abs(src(I))), src(I)!=0
            dst(I)=C,  src(I)=0
            Where C is large negative number (≈-700 in the current implementation)
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array, it should have double type or the same type as the source</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPow(System.IntPtr,System.IntPtr,System.Double)">
            <summary>
            The function cvPow raises every element of input array to p:
            dst(I)=src(I)p, if p is integer
            dst(I)=abs(src(I))p, otherwise
            That is, for non-integer power exponent the absolute values of input array elements are used. However, it is possible to get true values for negative values using some extra operations, as the following sample, computing cube root of array elements, shows:
            CvSize size = cvGetSize(src);
            CvMat* mask = cvCreateMat( size.height, size.width, CV_8UC1 );
            cvCmpS( src, 0, mask, CV_CMP_LT ); /* find negative elements */
            cvPow( src, dst, 1./3 );
            cvSubRS( dst, cvScalarAll(0), dst, mask ); /* negate the results of negative inputs */
            cvReleaseMat( &amp;mask );
            For some values of power, such as integer values, 0.5 and -0.5, specialized faster algorithms are used.
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array, should be the same type as the source</param>
            <param name="power">The exponent of power</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvExp(System.IntPtr,System.IntPtr)">
            <summary>
            The function cvExp calculates exponent of every element of input array:
            dst(I)=exp(src(I))
            Maximum relative error is ≈7e-6. Currently, the function converts denormalized values to zeros on output
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array, it should have double type or the same type as the source</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDFT(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.CV_DXT,System.Int32)">
            <summary>
            The function cvDFT performs forward or inverse transform of 1D or 2D floating-point array
            In case of real (single-channel) data, the packed format, borrowed from IPL, is used to to represent a result of forward Fourier transform or input for inverse Fourier transform
            </summary>
            <param name="src">Source array, real or complex</param>
            <param name="dst">Destination array of the same size and same type as the source</param>
            <param name="flags">Transformation flags</param>
            <param name="nonzero_rows">Number of nonzero rows to in the source array (in case of forward 2d transform), or a number of rows of interest in the destination array (in case of inverse 2d transform). If the value is negative, zero, or greater than the total number of rows, it is ignored. The parameter can be used to speed up 2d convolution/correlation when computing them via DFT. See the sample below</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDCT(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.CV_DCT_TYPE)">
            <summary>
            The function cvDCT performs forward or inverse transform of 1D or 2D floating-point array
            </summary>
            <param name="src">Source array, real 1D or 2D array</param>
            <param name="dst">Destination array of the same size and same type as the source</param>
            <param name="flags">Transformation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvClipLine(Emgu.CV.MCvSize,Emgu.CV.MCvPoint@,Emgu.CV.MCvPoint@)">
            <summary>
            The function cvClipLine calculates a part of the line segment which is entirely in the image. It returns 0 if the line segment is completely outside the image and 1 otherwise.
            </summary>
            <param name="img_size">Size of the image</param>
            <param name="pt1">First ending point of the line segment. It is modified by the function</param>
            <param name="pt2">Second ending point of the line segment. It is modified by the function.</param>
            <returns>It returns 0 if the line segment is completely outside the image and 1 otherwise.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAbsDiff(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvAbsDiff calculates absolute difference between two arrays.
            dst(I)c = abs(src1(I)c - src2(I)c).
            All the arrays must have the same data type and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAddWeighted(System.IntPtr,System.Double,System.IntPtr,System.Double,System.Double,System.IntPtr)">
            <summary>
            The function cvAddWeighted calculated weighted sum of two arrays as following:
            dst(I)=src1(I)*alpha+src2(I)*beta+gamma
            All the arrays must have the same type and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array.</param>
            <param name="alpha">Weight of the first array elements.</param>
            <param name="src2">The second source array. </param>
            <param name="beta">Weight of the second array elements.</param>
            <param name="gamma">Scalar, added to each sum. </param>
            <param name="dst">The destination array.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInRangeS(System.IntPtr,Emgu.CV.MCvScalar,Emgu.CV.MCvScalar,System.IntPtr)">
            <summary>
            The function cvInRangeS does the range check for every element of the input array:
            dst(I)=lower0 &lt;= src(I)0 &lt; upper0
            for a single-channel array,
            dst(I)=lower0 &lt;= src(I)0 &lt; upper0 &amp;&amp;
                lower1 &lt;= src(I)1 &lt; upper1
            for a two-channel array etc.
            dst(I) is set to 0xff (all '1'-bits) if src(I) is within the range and 0 otherwise. All the arrays must have the same size (or ROI size)
            </summary>
            <param name="src">The first source array</param>
            <param name="lower">The inclusive lower boundary</param>
            <param name="upper">The exclusive upper boundary</param>
            <param name="dst">The destination array, must have 8u or 8s type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDotProduct(System.IntPtr,System.IntPtr)">
            <summary>
            The function cvDotProduct calculates and returns the Euclidean dot product of two arrays.
            src1•src2 = sumI(src1(I)*src2(I))
            In case of multiple channel arrays the results for all channels are accumulated. In particular, cvDotProduct(a,a), where a is a complex vector, will return ||a||2. The function can process multi-dimensional arrays, row by row, layer by layer and so on.
            </summary>
            <param name="src1">The first source array.</param>
            <param name="src2">The second source array</param>
            <returns>the Euclidean dot product of two arrays</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateImage(Emgu.CV.MCvSize,Emgu.CV.CvEnum.IPL_DEPTH,System.Int32)">
            <summary>
            The function cvCreateImage creates the header and allocates data. 
            </summary>
            <param name="size">Image width and height.</param>
            <param name="depth">Bit depth of image elements</param>
            <param name="channels">
            Number of channels per element(pixel). Can be 1, 2, 3 or 4. The channels are interleaved, for example the usual data layout of a color image is:
            b0 g0 r0 b1 g1 r1 ...
            </param>
            <returns>A pointer to IplImage </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateImageHeader(Emgu.CV.MCvSize,Emgu.CV.CvEnum.IPL_DEPTH,System.Int32)">
            <summary>
            The function cvCreateImageHeader allocates, initializes, and returns the structure IplImage.
            </summary>
            <param name="size">Image width and height.</param>
            <param name="depth">Bit depth of image elements</param>
            <param name="channels">
            Number of channels per element(pixel). Can be 1, 2, 3 or 4. The channels are interleaved, for example the usual data layout of a color image is:
            b0 g0 r0 b1 g1 r1 ...
            </param>
            <returns> The structure IplImage</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitImageHeader(System.IntPtr,Emgu.CV.MCvSize,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            The function cvInitImageHeader initializes the image header structure, pointer to which is passed by the user, and returns the pointer.
            </summary>
            <param name="image">Image header to initialize.</param>
            <param name="size">Image width and height.</param>
            <param name="depth">Image depth </param>
            <param name="channels">Number of channels </param>
            <param name="origin">IPL_ORIGIN_TL or IPL_ORIGIN_BL.</param>
            <param name="align">Alignment for image rows, typically 4 or 8 bytes.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetData(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            The function cvSetData assigns user data to the array header.
            </summary>
            <param name="arr">Array header.</param>
            <param name="data">User data.</param>
            <param name="step">Full row length in bytes.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseImageHeader(System.IntPtr@)">
            <summary>
            The function cvReleaseImageHeader releases the header.
            </summary>
            <param name="image">Pointer to the deallocated header.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitMatHeader(System.IntPtr,System.Int32,System.Int32,Emgu.CV.CvEnum.MAT_DEPTH,System.IntPtr,System.Int32)">
            <summary>
            The function cvInitMatHeader initializes already allocated CvMat structure. It can be used to process raw data with OpenCV matrix functions.
            </summary>
            <param name="mat">Pointer to the matrix header to be initialized.</param>
            <param name="rows">Number of rows in the matrix.</param>
            <param name="cols">Number of columns in the matrix.</param>
            <param name="type">Type of the matrix elements.</param>
            <param name="data">Optional data pointer assigned to the matrix header</param>
            <param name="step">Full row width in bytes of the data assigned. By default, the minimal possible step is used, i.e., no gaps is assumed between subsequent rows of the matrix.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCopy(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvCopy copies selected elements from input array to output array:
            dst(I)=src(I) if mask(I)!=0. 
            If any of the passed arrays is of IplImage type, then its ROI and COI fields are used. Both arrays must have the same type, the same number of dimensions and the same size. The function can also copy sparse arrays (mask is not supported in this case).
            </summary>
            <param name="src">The source array</param>
            <param name="des">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetImageCOI(System.IntPtr,System.Int32)">
            <summary>
            The function cvSetImageCOI sets the channel of interest to a given value. Value 0 means that all channels are selected, 1 means that the first channel is selected etc. If ROI is NULL and coi != 0, ROI is allocated.
            </summary>
            <param name="image">Image header. </param>
            <param name="coi">Channel of interest.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetImageCOI(System.IntPtr)">
            <summary>
            The function cvGetImageCOI returns channel of interest of the image (it returns 0 if all the channels are selected).
            </summary>
            <param name="image">Image header. </param>
            <returns>channel of interest of the image (it returns 0 if all the channels are selected)</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvResetImageROI(System.IntPtr)">
            <summary>
            The function cvResetImageROI releases image ROI. After that the whole image is considered selected.
            </summary>
            <param name="image">Image header</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetImageROI(System.IntPtr,Emgu.CV.MCvRect)">
            <summary>
            The function cvSetImageROI sets the image ROI to a given rectangle. If ROI is NULL and the value of the parameter rect is not equal to the whole image, ROI is allocated. 
            </summary>
            <param name="image">Image header.</param>
            <param name="rect">ROI rectangle.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetImageROI(System.IntPtr)">
            <summary>
            The function cvGetImageCOI returns channel of interest of the image (it returns 0 if all the channels are selected).
            </summary>
            <param name="image">Image header.</param>
            <returns>channel of interest of the image (it returns 0 if all the channels are selected)</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateMemStorage(System.Int32)">
            <summary>
            The function cvCreateMemStorage creates a memory storage and returns pointer to it. Initially the storage is empty. All fields of the header, except the block_size, are set to 0.
            </summary>
            <param name="block_size"></param>
            <returns>Size of the storage blocks in bytes. If it is 0, the block size is set to default value - currently it is ≈64K. </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateMat(System.Int32,System.Int32,Emgu.CV.CvEnum.MAT_DEPTH)">
            <summary>
            The function cvCreateMat allocates header for the new matrix and underlying data, and returns a pointer to the created matrix. Matrices are stored row by row. All the rows are aligned by 4 bytes. 
            </summary>
            <param name="rows">Number of rows in the matrix.</param>
            <param name="cols">Number of columns in the matrix.</param>
            <param name="type">Type of the matrix elements.</param>
            <returns>A pointer to the created matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMat(System.Int32,System.Int32,Emgu.CV.CvEnum.MAT_DEPTH,System.IntPtr)">
            <summary>
            The function cvMat is a fast inline substitution for cvInitMatHeader. Namely, it is equivalent to:
                CvMat mat;
                cvInitMatHeader( &amp;mat, rows, cols, type, data, CV_AUTOSTEP );
            </summary>
            <param name="rows">Number of rows in the matrix.</param>
            <param name="cols">Number of columns in the matrix.</param>
            <param name="type">Type of the matrix elements (see CreateMat).</param>
            <param name="data">Optional data pointer assigned to the matrix header.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseMat(System.IntPtr@)">
            <summary>
            The function cvReleaseMat decrements the matrix data reference counter and releases matrix header
            </summary>
            <param name="mat">Double pointer to the matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvTranspose(System.IntPtr,System.IntPtr)">
            <summary>
            The function cvTranspose transposes matrix src1:
            dst(i,j)=src(j,i)
            Note that no complex conjugation is done in case of complex matrix. Conjugation should be done separately: look at the sample code in cvXorS for example
            </summary>
            <param name="src">The source matrix</param>
            <param name="dst">The destination matrix</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvLoad(System.String,System.IntPtr,System.String,System.IntPtr)">
            <summary>
            The function cvLoad loads object from file. It provides a simple interface to cvRead. After object is loaded, the file storage is closed and all the temporary buffers are deleted. Thus, to load a dynamic structure, such as sequence, contour or graph, one should pass a valid destination memory storage to the function.
            </summary>
            <param name="filename">File name</param>
            <param name="memstorage">Memory storage for dynamic structures, such as CvSeq or CvGraph. It is not used for matrices or images</param>
            <param name="name">Optional object name. If it is NULL, the first top-level object in the storage will be loaded</param>
            <param name="real_name">Optional output parameter that will contain name of the loaded object (useful if name=NULL). </param>
            <returns>Loaded object from file</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqSlice(System.IntPtr,Emgu.CV.MCvSlice,System.IntPtr,System.Boolean)">
            <summary>
            The function cvSeqSlice creates a sequence that represents the specified slice of the input sequence. The new sequence either shares the elements with the original sequence or has own copy of the elements. So if one needs to process a part of sequence but the processing function does not have a slice parameter, the required sub-sequence may be extracted using this function.
            </summary>
            <param name="seq">Sequence</param>
            <param name="slice">The part of the sequence to extract</param>
            <param name="storage">The destination storage to keep the new sequence header and the copied data if any. If it is NULL, the function uses the storage containing the input sequence.</param>
            <param name="copy_data">The flag that indicates whether to copy the elements of the extracted slice (copy_data!=0) or not (copy_data=0)</param>
            <returns>A pointer to CvSeq</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSet2D(System.IntPtr,System.Int32,System.Int32,Emgu.CV.MCvScalar)">
            <summary>
            The functions cvSet2D assign the new value to the particular element of array
            </summary>
            <param name="arr">Input array. </param>
            <param name="idx0">The first zero-based component of the element index</param>
            <param name="idx1">The second zero-based component of the element index</param>
            <param name="value">The assigned value</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFlip(System.IntPtr,System.IntPtr,System.Int32)">
             <summary>
             The function cvFlip flips the array in one of different 3 ways (row and column indices are 0-based):
             dst(i,j)=src(rows(src)-i-1,j) if flip_mode = 0
             dst(i,j)=src(i,cols(src1)-j-1) if flip_mode &gt; 0
             dst(i,j)=src(rows(src)-i-1,cols(src)-j-1) if flip_mode &lt; 0
             </summary>
             <param name="src">Source array.</param>
             <param name="dst">Destination array.</param>
             <param name="flip_mode">
             Specifies how to flip the array.
             flip_mode = 0 means flipping around x-axis, 
             flip_mode &gt; 0 (e.g. 1) means flipping around y-axis and 
             flip_mode &lt; 0 (e.g. -1) means flipping around both axises. 
            </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvLine(System.IntPtr,Emgu.CV.MCvPoint,Emgu.CV.MCvPoint,Emgu.CV.MCvScalar,System.Int32,Emgu.CV.CvEnum.LINE_TYPE,System.Int32)">
            <summary>
            The function cvLine draws the line segment between pt1 and pt2 points in the image. The line is clipped by the image or ROI rectangle. For non-antialiased lines with integer coordinates the 8-connected or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased lines are drawn using Gaussian filtering.
            </summary>
            <param name="img">The image</param>
            <param name="pt1">First point of the line segment</param>
            <param name="pt2">Second point of the line segment</param>
            <param name="color">Line color</param>
            <param name="thickness">Line thickness. </param>
            <param name="line_type">Type of the line:
            8 (or 0) - 8-connected line.
            4 - 4-connected line.
            CV_AA - antialiased line. 
            </param>
            <param name="shift">Number of fractional bits in the point coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRectangle(System.IntPtr,Emgu.CV.MCvPoint,Emgu.CV.MCvPoint,Emgu.CV.MCvScalar,System.Int32,Emgu.CV.CvEnum.LINE_TYPE,System.Int32)">
            <summary>
            The function cvRectangle draws a rectangle with two opposite corners pt1 and pt2
            </summary>
            <param name="img">Image</param>
            <param name="pt1">One of the rectangle vertices</param>
            <param name="pt2">Opposite rectangle vertex</param>
            <param name="color">Line color </param>
            <param name="thickness">Thickness of lines that make up the rectangle. Negative values make the function to draw a filled rectangle.</param>
            <param name="line_type">Type of the line</param>
            <param name="shift">Number of fractional bits in the point coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCircle(System.IntPtr,Emgu.CV.MCvPoint,System.Int32,Emgu.CV.MCvScalar,System.Int32,Emgu.CV.CvEnum.LINE_TYPE,System.Int32)">
            <summary>
            The function cvCircle draws a simple or filled circle with given center and radius. The circle is clipped by ROI rectangle.
            </summary>
            <param name="img">Image where the circle is drawn</param>
            <param name="center">Center of the circle</param>
            <param name="radius">Radius of the circle.</param>
            <param name="color">Circle color</param>
            <param name="thickness">Thickness of the circle outline if positive, otherwise indicates that a filled circle has to be drawn</param>
            <param name="line_type">Type of the circle boundary</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSplit(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvSplit divides a multi-channel array into separate single-channel arrays. Two modes are available for the operation. If the source array has N channels then if the first N destination channels are not NULL, all they are extracted from the source array, otherwise if only a single destination channel of the first N is not NULL, this particular channel is extracted, otherwise an error is raised. Rest of destination channels (beyond the first N) must always be NULL. For IplImage cvCopy with COI set can be also used to extract a single channel from the image
            </summary>
            <param name="src">Source array</param>
            <param name="dst0">Destination channels</param>
            <param name="dst1">Destination channels</param>
            <param name="dst2">Destination channels</param>
            <param name="dst3">Destination channels</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvEllipse(System.IntPtr,Emgu.CV.MCvPoint,Emgu.CV.MCvSize,System.Double,System.Double,System.Double,Emgu.CV.MCvScalar,System.Int32,Emgu.CV.CvEnum.LINE_TYPE,System.Int32)">
            <summary>
            The function cvEllipse draws a simple or thick elliptic arc or fills an ellipse sector. The arc is clipped by ROI rectangle. A piecewise-linear approximation is used for antialiased arcs and thick arcs. All the angles are given in degrees.
            </summary>
            <param name="img">Image</param>
            <param name="center">Center of the ellipse</param>
            <param name="axes">Length of the ellipse axes</param>
            <param name="angle">Rotation angle</param>
            <param name="start_angle">Starting angle of the elliptic arc</param>
            <param name="end_angle">Ending angle of the elliptic arc</param>
            <param name="color">Ellipse color</param>
            <param name="thickness">Thickness of the ellipse arc</param>
            <param name="line_type">Type of the ellipse boundary</param>
            <param name="shift">Number of fractional bits in the center coordinates and axes' values</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvConvertScale(System.IntPtr,System.IntPtr,System.Double,System.Double)">
            <summary>
            The function cvConvertScale has several different purposes and thus has several synonyms. It copies one array to another with optional scaling, which is performed first, and/or optional type conversion, performed after:
            dst(I)=src(I)*scale + (shift,shift,...)
            All the channels of multi-channel arrays are processed independently.
            The type conversion is done with rounding and saturation, that is if a result of scaling + conversion can not be represented exactly by a value of destination array element type, it is set to the nearest representable value on the real axis.
            In case of scale=1, shift=0 no prescaling is done. This is a specially optimized case and it has the appropriate cvConvert synonym. If source and destination array types have equal types, this is also a special case that can be used to scale and shift a matrix or an image and that fits to cvScale synonym.
            </summary>
            <param name="src">Source array</param>
            <param name="dst">Destination array</param>
            <param name="scale">Scale factor</param>
            <param name="shift">Value added to the scaled source array elements</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvConvertScaleAbs(System.IntPtr,System.IntPtr,System.Double,System.Double)">
            <summary>
            The function cvConvertScaleAbs is similar to the previous one, but it stores absolute values of the conversion results:
            dst(I)=abs(src(I)*scale + (shift,shift,...))
            The function supports only destination arrays of 8u (8-bit unsigned integers) type, for other types the function can be emulated by combination of cvConvertScale and cvAbs functions.
            </summary>
            <param name="src">Source array</param>
            <param name="dst">Destination array (should have 8u depth). </param>
            <param name="scale">ScaleAbs factor</param>
            <param name="shift">Value added to the scaled source array elements</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAvg(System.IntPtr,System.IntPtr)">
             <summary>
             The function cvAvg calculates the average value M of array elements, independently for each channel:
            N = sumI mask(I)!=0
            Mc = 1/N • sumI,mask(I)!=0 arr(I)c
            If the array is IplImage and COI is set, the function processes the selected channel only and stores the average to the first scalar component (S0).
             </summary>
             <param name="arr">The array</param>
             <param name="mask">The optional operation mask</param>
             <returns>average (mean) of array elements</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSum(System.IntPtr)">
            <summary>
            The function cvSum calculates sum S of array elements, independently for each channel
            Sc = sumI arr(I)c
            If the array is IplImage and COI is set, the function processes the selected channel only and stores the sum to the first scalar component (S0).
            </summary>
            <param name="arr">The array</param>
            <returns>The sum of arary elements</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetSeqElem(System.IntPtr,System.Int32)">
            <summary>
            The function cvGetSeqElem finds the element with the given index in the sequence and returns the pointer to it. If the element is not found, the function returns 0. The function supports negative indices, where -1 stands for the last sequence element, -2 stands for the one before last, etc. If the sequence is most likely to consist of a single sequence block or the desired element is likely to be located in the first block, then the macro CV_GET_SEQ_ELEM( elemType, seq, index ) should be used, where the parameter elemType is the type of sequence elements ( CvPoint for example), the parameter seq is a sequence, and the parameter index is the index of the desired element. The macro checks first whether the desired element belongs to the first block of the sequence and returns it if it does, otherwise the macro calls the main function GetSeqElem. Negative indices always cause the cvGetSeqElem call. The function has O(1) time complexity assuming that number of blocks is much smaller than the number of elements.
            </summary>
            <param name="seq">Sequence</param>
            <param name="index">Index of element</param>
            <returns>the pointer to the element with the given index in the sequence</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseImage(System.IntPtr@)">
            <summary>
            The function cvReleaseImage releases the header and the image data.
            </summary>
            <param name="image">Double pointer to the header of the deallocated image</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvClearSeq(System.IntPtr)">
            <summary>
            The function cvClearSeq removes all elements from the sequence. The function does not return the memory to the storage, but this memory is reused later when new elements are added to the sequence. This function time complexity is O(1). 
            </summary>
            <param name="seq">Sequence</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDrawContours(System.IntPtr,System.IntPtr,Emgu.CV.MCvScalar,Emgu.CV.MCvScalar,System.Int32,System.Int32,Emgu.CV.CvEnum.LINE_TYPE,Emgu.CV.MCvPoint)">
            <summary>
            The function cvDrawContours draws contour outlines in the image if thickness &gt;=0 or fills area bounded by the contours if thickness&lt;0.
            </summary>
            <param name="img">Image where the contours are to be drawn. Like in any other drawing function, the contours are clipped with the ROI</param>
            <param name="contour">Pointer to the first contour</param>
            <param name="external_color">Color of the external contours</param>
            <param name="hole_color">Color of internal contours </param>
            <param name="max_level">Maximal level for drawn contours. If 0, only contour is drawn. If 1, the contour and all contours after it on the same level are drawn. If 2, all contours after and all contours one level below the contours are drawn, etc. If the value is negative, the function does not draw the contours following after contour but draws child contours of contour up to abs(max_level)-1 level. </param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative the contour interiors are drawn</param>
            <param name="line_type">Type of the contour segments</param>
            <param name="offset">Shift all the point coordinates by the specified value. It is useful in case if the contours retrived in some image ROI and then the ROI offset needs to be taken into account during the rendering. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPutText(System.IntPtr,System.String,Emgu.CV.MCvPoint,System.IntPtr,Emgu.CV.MCvScalar)">
            <summary>
            The function cvPutText renders the text in the image with the specified font and color. The printed text is clipped by ROI rectangle. Symbols that do not belong to the specified font are replaced with the rectangle symbol.
            </summary>
            <param name="img">Input image</param>
            <param name="text">String to print</param>
            <param name="org">Coordinates of the bottom-left corner of the first letter</param>
            <param name="font">Pointer to the font structure</param>
            <param name="color">Text color</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseMemStorage(System.IntPtr@)">
            <summary>
            The function cvReleaseMemStorage deallocates all storage memory blocks or returns them to the parent, if any. Then it deallocates the storage header and clears the pointer to the storage. All children of the storage must be released before the parent is released.
            </summary>
            <param name="storage">Pointer to the released storage</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCvtSeqToArray(System.IntPtr,System.IntPtr,Emgu.CV.MCvSlice)">
            <summary>
            The function cvCvtSeqToArray copies the entire sequence or subsequence to the specified buffer and returns the pointer to the buffer
            </summary>
            <param name="seq">Sequence</param>
            <param name="elements">Pointer to the destination array that must be large enough. It should be a pointer to data, not a matrix header</param>
            <param name="slice">The sequence part to copy to the array</param>
            <returns>the pointer to the buffer</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMinMaxLoc(System.IntPtr,System.Double@,System.Double@,Emgu.CV.MCvPoint@,Emgu.CV.MCvPoint@,System.IntPtr)">
            <summary>
            The function MinMaxLoc finds minimum and maximum element values and their positions. The extremums are searched over the whole array, selected ROI (in case of IplImage) or, if mask is not NULL, in the specified array region. If the array has more than one channel, it must be IplImage with COI set. In case if multi-dimensional arrays min_loc->x and max_loc->x will contain raw (linear) positions of the extremums
            </summary>
            <param name="arr">The source array, single-channel or multi-channel with COI set</param>
            <param name="min_val">Pointer to returned minimum value</param>
            <param name="max_val">Pointer to returned maximum value</param>
            <param name="min_loc">Pointer to returned minimum location</param>
            <param name="max_loc">Pointer to returned maximum location</param>
            <param name="mask">The optional mask that is used to select a subarray</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitFont(System.IntPtr,Emgu.CV.CvEnum.FONT,System.Double,System.Double,System.Double,System.Int32,Emgu.CV.CvEnum.LINE_TYPE)">
            <summary>
            The function cvInitFont initializes the font structure that can be passed to text rendering functions
            </summary>
            <param name="font">Pointer to the font structure initialized by the function</param>
            <param name="font_face">Font name identifier. Only a subset of Hershey fonts are supported now</param>
            <param name="hscale">Horizontal scale. If equal to 1.0f, the characters have the original width depending on the font type. If equal to 0.5f, the characters are of half the original width</param>
            <param name="vscale">Vertical scale. If equal to 1.0f, the characters have the original height depending on the font type. If equal to 0.5f, the characters are of half the original height</param>
            <param name="shear">Approximate tangent of the character slope relative to the vertical line. Zero value means a non-italic font, 1.0f means ≈45° slope, etc. thickness Thickness of lines composing letters outlines. The function cvLine is used for drawing letters</param>
            <param name="thickness">Thickness of the text strokes</param>
            <param name="line_type">Type of the strokes</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGet1D(System.IntPtr,System.Int32)">
            <summary>
            The functions cvGet1D return the particular array element
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index</param>
            <returns>the particular array element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGet2D(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            The functions cvGet2D return the particular array element
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index</param>
            <param name="idx1">The second zero-based component of the element index</param>
            <returns>the particular array element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGet3D(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            The functions cvGet3D return the particular array element
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index</param>
            <param name="idx1">The second zero-based component of the element index</param>
            <param name="idx2">The third zero-based component of the element index</param>
            <returns>the particular array element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetReal1D(System.IntPtr,System.Int32)">
            <summary>
            The functions cvGetReal*D return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <returns>the particular element of single-channel array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetReal2D(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            The functions cvGetReal*D return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index</param>
            <returns>the particular element of single-channel array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetReal3D(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            The functions cvGetReal*D return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index</param>
            <param name="idx2">The third zero-based component of the element index </param>
            <returns>the particular element of single-channel array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvQueryHistValue_1D(System.IntPtr,System.Int32)">
            <summary>
            return the value of the specified bin of 1D histogram. In case of sparse histogram the function returns 0, if the bin is not present in the histogram, and no new bin is created. 
            </summary>
            <param name="hist">Histogram</param>
            <param name="idx0">Indices of the bin</param>
            <returns>the value of the specified bin of 1D histogram</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvQueryHistValue_2D(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            return the value of the specified bin of 2D histogram. In case of sparse histogram the function returns 0, if the bin is not present in the histogram, and no new bin is created. 
            </summary>
            <param name="hist">Histogram</param>
            <param name="idx0">Indices of the bin</param>
            <param name="idx1">Indices of the bin</param>
            <returns>the value of the specified bin of 2D histogram</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvQueryHistValue_3D(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            return the value of the specified bin of 3D histogram. In case of sparse histogram the function returns 0, if the bin is not present in the histogram, and no new bin is created. 
            </summary>
            <param name="hist">Histogram</param>
            <param name="idx0">Indices of the bin</param>
            <param name="idx1">Indices of the bin</param>
            <param name="idx2">Indices of the bin</param>
            <returns>the value of the specified bin of 3D histogram</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateSeq(System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            The function cvCreateSeq creates a sequence and returns the pointer to it. The function allocates the sequence header in the storage block as one continuous chunk and sets the structure fields flags, elem_size, header_size and storage to passed values, sets delta_elems to the default value (that may be reassigned using cvSetSeqBlockSize function), and clears other header fields, including the space after the first sizeof(CvSeq) bytes
            </summary>
            <param name="seq_flags">Flags of the created sequence. If the sequence is not passed to any function working with a specific type of sequences, the sequence value may be set to 0, otherwise the appropriate type must be selected from the list of predefined sequence types</param>
            <param name="header_size">Size of the sequence header; must be greater or equal to sizeof(CvSeq). If a specific type or its extension is indicated, this type must fit the base type header</param>
            <param name="elem_size">Size of the sequence elements in bytes. The size must be consistent with the sequence type. For example, for a sequence of points to be created, the element type CV_SEQ_ELTYPE_POINT should be specified and the parameter elem_size must be equal to sizeof(CvPoint). </param>
            <param name="storage">Sequence location.</param>
            <returns>A pointer to the sequence</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqPush(System.IntPtr,System.IntPtr)">
            <summary>
            The function cvSeqPush adds an element to the end of sequence and retuns pointer to the allocated element. If the input element is NULL, the function simply allocates a space for one more element.
            </summary>
            <param name="seq">Sequence</param>
            <param name="element">Added element</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqPushMulti(System.IntPtr,System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            The function cvSeqPushMulti adds several elements to either end of the sequence. The elements are added to the sequence in the same order as they are arranged in the input array but they can fall into different sequence blocks.
            </summary>
            <param name="seq">Sequence</param>
            <param name="elements">Added elements</param>
            <param name="count">Number of elements to push</param>
            <param name="in_front">if true, the elements are added to the beginning of sequence, otherwise the elements are added to the end of sequence </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvUseOptimized(System.Int32)">
            <summary>
            The function cvUseOptimized switches between the mode, where only pure C implementations from cxcore, OpenCV etc. are used, and the mode, where IPP and MKL functions are used if available. When cvUseOptimized(0) is called, all the optimized libraries are unloaded. The function may be useful for debugging, IPP&amp;MKL upgrade on the fly, online speed comparisons etc.  Note that by default the optimized plugins are loaded, so it is not necessary to call cvUseOptimized(1) in the beginning of the program (actually, it will only increase the startup time)
            </summary>
            <param name="on_off">1 to turn on optimization, 0 to turn off</param>
            <returns>The number of optimized functions loaded</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRandArr(System.UInt64@,System.IntPtr,Emgu.CV.CvEnum.RAND_TYPE,Emgu.CV.MCvScalar,Emgu.CV.MCvScalar)">
            <summary>
            The function cvRandArr fills the destination array with uniformly or normally distributed random numbers.
            </summary>
            <param name="rng">the seed for the random number generator</param>
            <param name="arr">The destination array</param>
            <param name="dist_type">Distribution type</param>
            <param name="param1">The first parameter of distribution. In case of uniform distribution it is the inclusive lower boundary of random numbers range. In case of normal distribution it is the mean value of random numbers</param>
            <param name="param2">The second parameter of distribution. In case of uniform distribution it is the exclusive upper boundary of random numbers range. In case of normal distribution it is the standard deviation of random numbers</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGEMM(System.IntPtr,System.IntPtr,System.Double,System.IntPtr,System.Double,System.IntPtr,Emgu.CV.CvEnum.GEMM_TYPE)">
            <summary>
            The function cvGEMM performs generalized matrix multiplication:
            dst = alpha*op(src1)*op(src2) + beta*op(src3), where op(X) is X or XT
            </summary>
            <param name="src1">The first source array. </param>
            <param name="src2">The second source array. </param>
            <param name="alpha"></param>
            <param name="src3">The third source array (shift). Can be NULL, if there is no shift.</param>
            <param name="beta"></param>
            <param name="dst">The destination array.</param>
            <param name="tABC"></param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetIdentity(System.IntPtr,Emgu.CV.MCvScalar)">
            <summary>
            The function cvSetIdentity initializes scaled identity matrix:
            arr(i,j)=value if i=j,
            0 otherwise
            </summary>
            <param name="mat">The matrix to initialize (not necesserily square).</param>
            <param name="value">The value to assign to the diagonal elements.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetRawData(System.IntPtr,System.IntPtr@,System.Int32@,Emgu.CV.MCvSize@)">
            <summary>
            The function cvGetRawData fills output variables with low-level information about the array data. All output parameters are optional, so some of the pointers may be set to NULL. If the array is IplImage with ROI set, parameters of ROI are returned. 
            </summary>
            <param name="arr">Array header</param>
            <param name="data">Output pointer to the whole image origin or ROI origin if ROI is set</param>
            <param name="step">Output full row length in bytes</param>
            <param name="roi_size">Output ROI size</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvTrace(System.IntPtr)">
            <summary>
            The function cvTrace returns sum of diagonal elements of the matrix <paramref name="src1"/>.
            </summary>
            <param name="mat">the matrix</param>
            <returns>sum of diagonal elements of the matrix src1</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDet(System.IntPtr)">
            <summary>
            The function cvDet returns determinant of the square matrix mat. The direct method is used for small matrices and Gaussian elimination is used for larger matrices. For symmetric positive-determined matrices it is also possible to run SVD with U=V=NULL and then calculate determinant as a product of the diagonal elements of W
            </summary>
            <param name="mat">The pointer to the matrix</param>
            <returns>determinant of the square matrix mat</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCheckArr(System.IntPtr,Emgu.CV.CvEnum.CHECK_TYPE,System.Double,System.Double)">
            <summary>
            The function cvCheckArr checks that every array element is neither NaN nor ±Infinity. If CV_CHECK_RANGE is set, it also checks that every element is greater than or equal to minVal and less than maxVal. 
            </summary>
            <param name="arr">The array to check.</param>
            <param name="flags">The operation flags, CHECK_NAN_INFINITY or combination of
            CHECK_RANGE - if set, the function checks that every value of array is within [minVal,maxVal) range, otherwise it just checks that every element is neigther NaN nor ±Infinity.
            CHECK_QUIET - if set, the function does not raises an error if an element is invalid or out of range 
            </param>
            <param name="min_val">The inclusive lower boundary of valid values range. It is used only if CHECK_RANGE is set.</param>
            <param name="max_val">The exclusive upper boundary of valid values range. It is used only if CHECK_RANGE is set.</param>
            <returns>Returns nonzero if the check succeeded, i.e. all elements are valid and within the range, and zero otherwise. In the latter case if CV_CHECK_QUIET flag is not set, the function raises runtime error.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetNumThreads">
            <summary>
            The function cvGetNumThreads return the current number of threads that are used by parallelized (via OpenMP) OpenCV functions.
            </summary>
            <returns>the current number of threads that are used by parallelized (via OpenMP) OpenCV functions</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetNumThreads(System.Int32)">
            <summary>
            The function cvSetNumThreads sets the number of threads that are used by parallelized OpenCV functions. 
            </summary>
            <param name="threads_count">The number of threads that are used by parallelized OpenCV functions. When the argument is zero or negative, and at the beginning of the program, the number of threads is set to the number of processors in the system, as returned by the function omp_get_num_procs() from OpenMP runtime. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetThreadNum">
            <summary>
            The function cvGetThreadNum returns the index, from 0 to cvGetNumThreads()-1, of the thread that called the function. It is a wrapper for the function omp_get_thread_num() from OpenMP runtime. The retrieved index may be used to access local-thread data inside the parallelized code fragments. 
            </summary>
            <returns>The index, from 0 to cvGetNumThreads()-1, of the thread that called the function. It is a wrapper for the function omp_get_thread_num() from OpenMP runtime. The retrieved index may be used to access local-thread data inside the parallelized code fragments. </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCmp(System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.CMP_TYPE)">
            <summary>
            The function cvCmp compares the corresponding elements of two arrays and fills the destination mask array:
            dst(I)=src1(I) op src2(I),
            dst(I) is set to 0xff (all '1'-bits) if the particular relation between the elements is true and 0 otherwise. 
            All the arrays must have the same type, except the destination, and the same size (or ROI size)
            </summary>
            <param name="src1">The first image to compare with</param>
            <param name="src2">The second image to comapare with</param>
            <param name="dst">dst(I) is set to 0xff (all '1'-bits) if the particular relation between the elements is true and 0 otherwise.</param>
            <param name="cmp_op">The comparison operator type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCmpS(System.IntPtr,System.Double,System.IntPtr,Emgu.CV.CvEnum.CMP_TYPE)">
            <summary>
            The function cvCmpS compares the corresponding elements of array and scalar and fills the destination mask array:
            dst(I)=src(I) op scalar,
            where op is '=', '&gt;', '&gt;=', '&lt;', '&lt;=' or '!='.
            dst(I) is set to 0xff (all '1'-bits) if the particular relation between the elements is true and 0 otherwise. All the arrays must have the same size (or ROI size)
            </summary>
            <param name="src">The source array, must have a single channel</param>
            <param name="value">The scalar value to compare each array element with</param>
            <param name="dst">The destination array, must have 8u or 8s type</param>
            <param name="cmp_op">The flag specifying the relation between the elements to be checked</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvErrorStr(System.Int32)">
            <summary>
            The function cvErrorStr returns the textual description for the specified error status code. In case of unknown status the function returns NULL pointer. 
            </summary>
            <param name="status">The error status</param>
            <returns>the textual description for the specified error status code.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPyrDown(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.FILTER_TYPE)">
            <summary>
            The function cvPyrDown performs downsampling step of Gaussian pyramid decomposition. First it convolves source image with the specified filter and then downsamples the image by rejecting even rows and columns.
            </summary>
            <param name="src">The source image.</param>
            <param name="dst">The destination image, should have 2x smaller width and height than the source.</param>
            <param name="filter">Type of the filter used for convolution; only CV_GAUSSIAN_5x5 is currently supported.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPyrUp(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.FILTER_TYPE)">
            <summary>
            The function cvPyrUp performs up-sampling step of Gaussian pyramid decomposition. First it upsamples the source image by injecting even zero rows and columns and then convolves result with the specified filter multiplied by 4 for interpolation. So the destination image is four times larger than the source image.
            </summary>
            <param name="src">The source image.</param>
            <param name="dst">The destination image, should have 2x smaller width and height than the source.</param>
            <param name="filter">Type of the filter used for convolution; only CV_GAUSSIAN_5x5 is currently supported.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvErode(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
             <summary>
             The function cvErode erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken:
             dst=erode(src,element):  dst(x,y)=min((x',y') in element))src(x+x',y+y')
            The function supports the in-place mode. Erosion can be applied several (iterations) times. In case of color image each channel is processed independently.
             </summary>
             <param name="src">Source image. </param>
             <param name="dst">Destination image</param>
             <param name="element">Structuring element used for erosion. If it is NULL, a 3×3 rectangular structuring element is used.</param>
             <param name="iterations">Number of times erosion is applied.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDilate(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            The function cvDilate dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken
            The function supports the in-place mode. Dilation can be applied several (iterations) times. In case of color image each channel is processed independently
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="element">Structuring element used for erosion. If it is NULL, a 3×3 rectangular structuring element is used</param>
            <param name="iterations">Number of times erosion is applied</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvResize(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.INTER)">
            <summary>
            The function cvResize resizes image src so that it fits exactly to dst. If ROI is set, the function consideres the ROI as supported as usual
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image</param>
            <param name="interpolation">Interpolation method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseHaarClassifierCascade(System.IntPtr@)">
            <summary>
            The function cvReleaseHaarClassifierCascade deallocates the cascade that has been created manually or loaded using cvLoadHaarClassifierCascade or cvLoad
            </summary>
            <param name="cascade">Double pointer to the released cascade. The pointer is cleared by the function. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInpaint(System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.INPAINT_TYPE,System.Double)">
            <summary>
            The function cvInpaint reconstructs the selected image area from the pixel near the area boundary. The function may be used to remove dust and scratches from a scanned photo, or to remove undesirable objects from still images or video.
            </summary>
            <param name="src">The input 8-bit 1-channel or 3-channel image</param>
            <param name="mask">The inpainting mask, 8-bit 1-channel image. Non-zero pixels indicate the area that needs to be inpainted</param>
            <param name="dst">The output image of the same format and the same size as input</param>
            <param name="flags">The inpainting method</param>
            <param name="inpaintRadius">The radius of circlular neighborhood of each point inpainted that is considered by the algorithm</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRunningAvg(System.IntPtr,System.IntPtr,System.Double,System.IntPtr)">
            <summary>
            The function cvRunningAvg calculates weighted sum of input image image and the accumulator acc so that acc becomes a running average of frame sequence:
            acc(x,y)=(1-α)•acc(x,y) + α•image(x,y) if mask(x,y)!=0
            where α (alpha) regulates update speed (how fast accumulator forgets about previous frames). 
            </summary>
            <param name="image">Input image, 1- or 3-channel, 8-bit or 32-bit floating point (each channel of multi-channel image is processed independently). </param>
            <param name="acc">Accumulator of the same number of channels as input image, 32-bit or 64-bit floating-point. </param>
            <param name="alpha">Weight of input image</param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSmooth(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.SMOOTH_TYPE,System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            The function cvSmooth smooths image using one of several methods. Every of the methods has some features and restrictions listed below
            Blur with no scaling works with single-channel images only and supports accumulation of 8-bit to 16-bit format (similar to cvSobel and cvLaplace) and 32-bit floating point to 32-bit floating-point format.
            Simple blur and Gaussian blur support 1- or 3-channel, 8-bit and 32-bit floating point images. These two methods can process images in-place.
            Median and bilateral filters work with 1- or 3-channel 8-bit images and can not process images in-place.
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image</param>
            <param name="type">Type of the smoothing</param>
            <param name="param1">The first parameter of smoothing operation</param>
            <param name="param2">The second parameter of smoothing operation. In case of simple scaled/non-scaled and Gaussian blur if param2 is zero, it is set to param1</param>
            <param name="param3">In case of Gaussian kernel this parameter may specify Gaussian sigma (standard deviation). If it is zero, it is calculated from the kernel size:
            sigma = (n/2 - 1)*0.3 + 0.8, where n=param1 for horizontal kernel,
            n=param2 for vertical kernel.
            With the standard sigma for small kernels (3×3 to 7×7) the performance is better. If param3 is not zero, while param1 and param2 are zeros, the kernel size is calculated from the sigma (to provide accurate enough operation). 
            </param>
            <param name="param4">In case of non-square Gaussian kernel the parameter may be used to specify a different (from param3) sigma in the vertical direction</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSobel(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
             <summary>
             The Sobel operators combine Gaussian smoothing and differentiation so the result is more or less robust to the noise. Most often, the function is called with (xorder=1, yorder=0, aperture_size=3) or (xorder=0, yorder=1, aperture_size=3) to calculate first x- or y- image derivative. The first case corresponds to
             <pre> |-1  0  1|
              |-2  0  2|
              |-1  0  1|</pre>
            kernel and the second one corresponds to
              |-1 -2 -1|
              | 0  0  0|
              | 1  2  1|
            or
              | 1  2  1|
              | 0  0  0|
              |-1 -2 -1|
            kernel, depending on the image origin (origin field of IplImage structure). No scaling is done, so the destination image usually has larger by absolute value numbers than the source image. To avoid overflow, the function requires 16-bit destination image if the source image is 8-bit. The result can be converted back to 8-bit using cvConvertScale or cvConvertScaleAbs functions. Besides 8-bit images the function can process 32-bit floating-point images. Both source and destination must be single-channel images of equal size or ROI size
             </summary>
             <param name="src">Source image.</param>
             <param name="dst">Destination image</param>
             <param name="xorder">Order of the derivative x </param>
             <param name="yorder">Order of the derivative y</param>
             <param name="aperture_size">Size of the extended Sobel kernel, must be 1, 3, 5 or 7. In all cases except 1, aperture_size ×aperture_size separable kernel will be used to calculate the derivative. For aperture_size=1 3x1 or 1x3 kernel is used (Gaussian smoothing is not done). There is also special value CV_SCHARR (=-1) that corresponds to 3x3 Scharr filter that may give more accurate results than 3x3 Sobel. Scharr aperture is: 
             | -3 0  3|
             |-10 0 10|
             | -3 0  3|
            for x-derivative or transposed for y-derivative. 
            </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvLaplace(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            The function cvLaplace calculates Laplacian of the source image by summing second x- and y- derivatives calculated using Sobel operator:
            dst(x,y) = d2src/dx2 + d2src/dy2
            Specifying aperture_size=1 gives the fastest variant that is equal to convolving the image with the following kernel:
            |0  1  0|
            |1 -4  1|
            |0  1  0|
            Similar to cvSobel function, no scaling is done and the same combinations of input and output formats are supported. 
            </summary>
            <param name="src">Source image. </param>
            <param name="dst">Destination image. </param>
            <param name="aperture_size">Aperture size </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCanny(System.IntPtr,System.IntPtr,System.Double,System.Double,System.Int32)">
            <summary>
            The function cvCanny finds the edges on the input image image and marks them in the output image edges using the Canny algorithm. The smallest of threshold1 and threshold2 is used for edge linking, the largest - to find initial segments of strong edges.
            </summary>
            <param name="image">Input image</param>
            <param name="edges">Image to store the edges found by the function</param>
            <param name="threshold1">The first threshold</param>
            <param name="threshold2">The second threshold.</param>
            <param name="aperture_size">Aperture parameter for Sobel operator </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvArcLength(System.IntPtr,Emgu.CV.MCvSlice,System.Int32)">
            <summary>
            The function cvArcLength calculates length or curve as sum of lengths of segments between subsequent points
            </summary>
            <param name="curve">Sequence or array of the curve points</param>
            <param name="slice">Starting and ending points of the curve, by default the whole curve length is calculated</param>
            <param name="is_closed">
            Indicates whether the curve is closed or not. There are 3 cases:
            is_closed=0 - the curve is assumed to be unclosed. 
            is_closed&gt;0 - the curve is assumed to be closed. 
            is_closed&lt;0 - if curve is sequence, the flag CV_SEQ_FLAG_CLOSED of ((CvSeq*)curve)-&gt;flags is checked to determine if the curve is closed or not, otherwise (curve is represented by array (CvMat*) of points) it is assumed to be unclosed. 
            </param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCheckContourConvexity(System.IntPtr)">
            <summary>
            The function cvCheckContourConvexity tests whether the input contour is convex or not. The contour must be simple, i.e. without self-intersections. 
            </summary>
            <param name="contour">Tested contour (sequence or array of points). </param>
            <returns>true if convex</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvContourArea(System.IntPtr,Emgu.CV.MCvSlice)">
            <summary>
            The function cvContourArea calculates area of the whole contour or contour section. 
            </summary>
            <param name="contour">Seq (sequence or array of vertices). </param>
            <param name="slice">Starting and ending points of the contour section of interest, by default area of the whole contour is calculated</param>
            <returns>The area of the whole contour or contour section</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvBoundingRect(System.IntPtr,System.Boolean)">
            <summary>
            The function cvBoundingRect returns the up-right bounding rectangle for 2d point set
            </summary>
            <param name="points">Either a 2D point set, represented as a sequence (CvSeq*, CvContour*) or vector (CvMat*) of points, or 8-bit single-channel mask image (CvMat*, IplImage*), in which non-zero pixels are considered</param>
            <param name="update">The update flag. Here is list of possible combination of the flag values and type of contour: 
            points is CvContour*, update=false: the bounding rectangle is not calculated, but it is read from rect field of the contour header. 
            points is CvContour*, update=true: the bounding rectangle is calculated and written to rect field of the contour header. For example, this mode is used by cvFindContours. 
            points is CvSeq* or CvMat*: update is ignored, the bounding rectangle is calculated and returned. 
            </param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvContourPerimeter(System.IntPtr)">
            <summary>
            Find the perimeter of the contour
            </summary>
            <param name="contour">Pointer to the contour</param>
            <returns>the perimeter of the contour</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvApproxPoly(System.IntPtr,System.Int32,System.IntPtr,Emgu.CV.CvEnum.APPROX_POLY_TYPE,System.Double,System.Int32)">
            <summary>
            The function cvApproxPoly approximates one or more curves and returns the approximation result[s]. In case of multiple curves approximation the resultant tree will have the same structure as the input one (1:1 correspondence). 
            </summary>
            <param name="src_seq">Sequence of array of points</param>
            <param name="header_size">Header size of approximated curve[s].</param>
            <param name="storage">Container for approximated contours. If it is NULL, the input sequences' storage is used</param>
            <param name="method">Approximation method</param>
            <param name="parameter">Desired approximation accuracy</param>
            <param name="parameter2">If case if src_seq is sequence it means whether the single sequence should be approximated or all sequences on the same level or below src_seq (see cvFindContours for description of hierarchical contour structures). And if src_seq is array (CvMat*) of points, the parameter specifies whether the curve is closed (parameter2!=0) or not (parameter2=0). </param>
            <returns> the approximation result</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvClearHist(System.IntPtr)">
            <summary>
            The function cvClearHist sets all histogram bins to 0 in case of dense histogram and removes all histogram bins in case of sparse array
            </summary>
            <param name="hist">Histogram</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFilter2D(System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.MCvPoint)">
            <summary>
            The function cvFilter2D applies arbitrary linear filter to the image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values from the nearest pixels that is inside the image
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image</param>
            <param name="kernel">Convolution kernel, single-channel floating point matrix. If you want to apply different kernels to different channels, split the image using cvSplit into separate color planes and process them individually</param>
            <param name="anchor">The anchor of the kernel that indicates the relative position of a filtered point within the kernel. The anchor shoud lie within the kernel. The special default value (-1,-1) means that it is at the kernel center</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvThreshold(System.IntPtr,System.IntPtr,System.Double,System.Double,Emgu.CV.CvEnum.THRESH)">
            <summary>
            The function cvThreshold applies fixed-level thresholding to single-channel array. The function is typically used to get bi-level (binary) image out of grayscale image (cvCmpS could be also used for this purpose) or for removing a noise, i.e. filtering out pixels with too small or too large values. There are several types of thresholding the function supports that are determined by threshold_type
            </summary>
            <param name="src">Source array (single-channel, 8-bit of 32-bit floating point). </param>
            <param name="dst">Destination array; must be either the same type as src or 8-bit. </param>
            <param name="threshold">Threshold value</param>
            <param name="max_value">Maximum value to use with CV_THRESH_BINARY and CV_THRESH_BINARY_INV thresholding types</param>
            <param name="threshold_type">Thresholding type </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAdaptiveThreshold(System.IntPtr,System.IntPtr,System.Double,Emgu.CV.CvEnum.ADAPTIVE_THRESHOLD_TYPE,Emgu.CV.CvEnum.THRESH,System.Int32,System.Double)">
            <summary>
            The function cvAdaptiveThreshold transforms grayscale image to binary
            image. Threshold calculated individually for each pixel. For the method
            CV_ADAPTIVE_THRESH_MEAN_C it is a mean of block_size × block_size pixel
            neighborhood, subtracted by param1. For the method
            CV_ADAPTIVE_THRESH_GAUSSIAN_C it is a weighted sum (gaussian) of block_size
            × block_size pixel neighborhood, subtracted by param1.
            </summary>
            <param name="src">Source array (single-channel, 8-bit of 32-bit floating point). </param>
            <param name="dst">Destination array; must be either the same type as src or 8-bit. </param>
            <param name="max_value">Maximum value to use with CV_THRESH_BINARY and CV_THRESH_BINARY_INV thresholding types</param>
            <param name="adaptive_type">Adaptive_method </param>
            <param name="threshold_type">Thresholding type </param>
            <param name="block_size">The size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, ... </param>
            <param name="param1">Constant subtracted from mean or weighted mean. It may be negative. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvThreshHist(System.IntPtr,System.Double)">
            <summary>
            The function cvThreshHist clears histogram bins that are below the specified threshold
            </summary>
            <param name="hist">Pointer to the histogram</param>
            <param name="threshold">Threshold level</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSampleLine(System.IntPtr,Emgu.CV.MCvPoint,Emgu.CV.MCvPoint,System.IntPtr,System.Int32)">
            <summary>
            The function cvSampleLine implements a particular case of application of line iterators. The function reads all the image points lying on the line between pt1 and pt2, including the ending points, and stores them into the buffer
            </summary>
            <param name="image">Image to sample the line from</param>
            <param name="pt1">Starting the line point.</param>
            <param name="pt2">Ending the line point</param>
            <param name="buffer">Buffer to store the line points; must have enough size to store max( |pt2.x-pt1.x|+1, |pt2.y-pt1.y|+1 ) points in case of 8-connected line and |pt2.x-pt1.x|+|pt2.y-pt1.y|+1 in case of 4-connected line</param>
            <param name="connectivity">The line connectivity, 4 or 8</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvHaarDetectObjects(System.IntPtr,System.IntPtr,System.IntPtr,System.Double,System.Int32,System.Int32,Emgu.CV.MCvSize)">
            <summary>
            The function cvHaarDetectObjects finds rectangular regions in the given image that are likely to contain objects the cascade has been trained for and returns those regions as a sequence of rectangles. The function scans the image several times at different scales (see cvSetImagesForHaarClassifierCascade). Each time it considers overlapping regions in the image and applies the classifiers to the regions using cvRunHaarClassifierCascade. It may also apply some heuristics to reduce number of analyzed regions, such as Canny prunning. After it has proceeded and collected the candidate rectangles (regions that passed the classifier cascade), it groups them and returns a sequence of average rectangles for each large enough group. The default parameters (scale_factor=1.1, min_neighbors=3, flags=0) are tuned for accurate yet slow object detection. For a faster operation on real video images the settings are: scale_factor=1.2, min_neighbors=2, flags=CV_HAAR_DO_CANNY_PRUNING, min_size=&lt;minimum possible face size&gt; (for example, ~1/4 to 1/16 of the image area in case of video conferencing). 
            </summary>
            <param name="image">Image to detect objects in.</param>
            <param name="cascade">Haar classifier cascade in internal representation</param>
            <param name="storage">Memory storage to store the resultant sequence of the object candidate rectangles</param>
            <param name="scale_factor">The factor by which the search window is scaled between the subsequent scans, for example, 1.1 means increasing window by 10%</param>
            <param name="min_neighbors">Minimum number (minus 1) of neighbor rectangles that makes up an object. All the groups of a smaller number of rectangles than min_neighbors-1 are rejected. If min_neighbors is 0, the function does not any grouping at all and returns all the detected candidate rectangles, which may be useful if the user wants to apply a customized grouping procedure</param>
            <param name="flags">Mode of operation. Currently the only flag that may be specified is CV_HAAR_DO_CANNY_PRUNING. If it is set, the function uses Canny edge detector to reject some image regions that contain too few or too much edges and thus can not contain the searched object. The particular threshold values are tuned for face detection and in this case the pruning speeds up the processing</param>
            <param name="min_size">Minimum window size. By default, it is set to the size of samples the classifier has been trained on (~20×20 for face detection). </param>
            <returns>Rectangular regions in the given image that are likely to contain objects the cascade has been trained for</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindContours(System.IntPtr,System.IntPtr,System.IntPtr@,System.Int32,Emgu.CV.CvEnum.RETR_TYPE,Emgu.CV.CvEnum.CHAIN_APPROX_METHOD,Emgu.CV.MCvPoint)">
            <summary>
            The function cvFindContours retrieves contours from the binary image and returns the number of retrieved contours. The pointer first_contour is filled by the function. It will contain pointer to the first most outer contour or NULL if no contours is detected (if the image is completely black). Other contours may be reached from first_contour using h_next and v_next links. The sample in cvDrawContours discussion shows how to use contours for connected component detection. Contours can be also used for shape analysis and object recognition - see squares.c in OpenCV sample directory
            </summary>
            <param name="image">The source 8-bit single channel image. Non-zero pixels are treated as 1’s, zero pixels remain 0’s - that is image treated as binary. To get such a binary image from grayscale, one may use cvThreshold, cvAdaptiveThreshold or cvCanny. The function modifies the source image content</param>
            <param name="storage">Container of the retrieved contours</param>
            <param name="first_contour">Output parameter, will contain the pointer to the first outer contour</param>
            <param name="header_size">Size of the sequence header, &gt;=sizeof(CvChain) if method=CV_CHAIN_CODE, and &gt;=sizeof(CvContour) otherwise</param>
            <param name="mode">Retrieval mode</param>
            <param name="method">Approximation method (for all the modes, except CV_RETR_RUNS, which uses built-in approximation). </param>
            <param name="offset">Offset, by which every contour point is shifted. This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvHoughCircles(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.HOUGH_TYPE,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            The function cvHoughCircles finds circles in grayscale image using some modification of Hough transform
            </summary>
            <param name="image">The input 8-bit single-channel grayscale image</param>
            <param name="circle_storage">The storage for the circles detected. It can be a memory storage (in this case a sequence of circles is created in the storage and returned by the function) or single row/single column matrix (CvMat*) of type CV_32FC3, to which the circles' parameters are written. The matrix header is modified by the function so its cols or rows will contain a number of lines detected. If circle_storage is a matrix and the actual number of lines exceeds the matrix size, the maximum possible number of circles is returned. Every circle is encoded as 3 floating-point numbers: center coordinates (x,y) and the radius</param>
            <param name="method">Currently, the only implemented method is CV_HOUGH_GRADIENT</param>
            <param name="dp">Resolution of the accumulator used to detect centers of the circles. For example, if it is 1, the accumulator will have the same resolution as the input image, if it is 2 - accumulator will have twice smaller width and height, etc</param>
            <param name="min_dist">Minimum distance between centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed</param>
            <param name="param1">The first method-specific parameter. In case of CV_HOUGH_GRADIENT it is the higher threshold of the two passed to Canny edge detector (the lower one will be twice smaller). </param>
            <param name="param2">The second method-specific parameter. In case of CV_HOUGH_GRADIENT it is accumulator threshold at the center detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first</param>
            <param name="min_radius">Minimal radius of the circles to search for</param>
            <param name="max_radius">Maximal radius of the circles to search for. By default the maximal radius is set to max(image_width, image_height). </param>
            <returns>Pointer to the sequence of circles</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCvtColor(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.COLOR_CONVERSION)">
            <summary>
            The function cvCvtColor converts input image from one color space to another. The function ignores colorModel and channelSeq fields of IplImage header, so the source image color space should be specified correctly (including order of the channels in case of RGB space, e.g. BGR means 24-bit format with B0 G0 R0 B1 G1 R1 ... layout, whereas RGB means 24-bit format with R0 G0 B0 R1 G1 B1 ... layout). 
            </summary>
            <param name="src">The source 8-bit (8u), 16-bit (16u) or single-precision floating-point (32f) image</param>
            <param name="dst">The destination image of the same data type as the source one. The number of channels may be different</param>
            <param name="code">Color conversion operation that can be specifed using CV_src_color_space2dst_color_space constants </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvHoughLines2(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.HOUGH_TYPE,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            The function cvHoughLines2 implements a few variants of Hough transform for line detection
            </summary>
            <param name="image">The input 8-bit single-channel binary image. In case of probabilistic method the image is modified by the function</param>
            <param name="line_storage">The storage for the lines detected. It can be a memory storage (in this case a sequence of lines is created in the storage and returned by the function) or single row/single column matrix (CvMat*) of a particular type (see below) to which the lines' parameters are written. The matrix header is modified by the function so its cols or rows will contain a number of lines detected. If line_storage is a matrix and the actual number of lines exceeds the matrix size, the maximum possible number of lines is returned (in case of standard hough transform the lines are sorted by the accumulator value). </param>
            <param name="method">The Hough transform variant</param>
            <param name="rho">Distance resolution in pixel-related units</param>
            <param name="theta">Angle resolution measured in radians</param>
            <param name="threshold">Threshold parameter. A line is returned by the function if the corresponding accumulator value is greater than threshold</param>
            <param name="param1">The first method-dependent parameter:
            For classical Hough transform it is not used (0). 
            For probabilistic Hough transform it is the minimum line length. 
            For multi-scale Hough transform it is divisor for distance resolution rho. (The coarse distance resolution will be rho and the accurate resolution will be (rho / param1))
            </param>
            <param name="param2">The second method-dependent parameter:
            For classical Hough transform it is not used (0). 
            For probabilistic Hough transform it is the maximum gap between line segments lieing on the same line to treat them as the single line segment (i.e. to join them). 
            For multi-scale Hough transform it is divisor for angle resolution theta. (The coarse angle resolution will be theta and the accurate resolution will be (theta / param2)). 
            </param>
            <returns>Pointer to the decetected lines</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMoments(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            The function cvMoments calculates spatial and central moments up to the third order and writes them to moments. The moments may be used then to calculate gravity center of the shape, its area, main axises and various shape characeteristics including 7 Hu invariants.
            </summary>
            <param name="arr">Image (1-channel or 3-channel with COI set) or polygon (CvSeq of points or a vector of points)</param>
            <param name="moments">Pointer to returned moment state structure</param>
            <param name="binary">(For images only) If the flag is non-zero, all the zero pixel values are treated as zeroes, all the others are treated as 1’s</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGoodFeaturesToTrack(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32@,System.Double,System.Double,System.IntPtr,System.Int32,System.Int32,System.Double)">
            <summary>
            The function cvGoodFeaturesToTrack finds corners with big eigenvalues in the image. The function first calculates the minimal eigenvalue for every source image pixel using cvCornerMinEigenVal function and stores them in eig_image. Then it performs non-maxima suppression (only local maxima in 3x3 neighborhood remain). The next step is rejecting the corners with the minimal eigenvalue less than quality_level•max(eig_image(x,y)). Finally, the function ensures that all the corners found are distanced enough one from another by considering the corners (the most strongest corners are considered first) and checking that the distance between the newly considered feature and the features considered earlier is larger than min_distance. So, the function removes the features than are too close to the stronger features.
            </summary>
            <param name="image">The source 8-bit or floating-point 32-bit, single-channel image</param>
            <param name="eig_image">Temporary floating-point 32-bit image of the same size as image</param>
            <param name="temp_image">Another temporary image of the same size and same format as eig_image</param>
            <param name="corners">Output parameter. Detected corners</param>
            <param name="corner_count">Output parameter. Number of detected corners</param>
            <param name="quality_level">Multiplier for the maxmin eigenvalue; specifies minimal accepted quality of image corners</param>
            <param name="min_distance">Limit, specifying minimum possible distance between returned corners; Euclidian distance is used</param>
            <param name="mask">Region of interest. The function selects points either in the specified region or in the whole image if the mask is NULL</param>
            <param name="block_size">Size of the averaging block, passed to underlying cvCornerMinEigenVal or cvCornerHarris used by the function</param>
            <param name="use_harris">If nonzero, Harris operator (cvCornerHarris) is used instead of default cvCornerMinEigenVal.</param>
            <param name="k">Free parameter of Harris detector; used only if use_harris≠0</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindFundamentalMat(System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.CV_FM,System.Double,System.Double,System.IntPtr)">
            <summary>
            The function cvFindFundamentalMat calculates fundamental matrix using one of four methods listed above and returns the number of fundamental matrices found (1 or 3) and 0, if no matrix is found. 
            </summary>
            <param name="points1">Array of the first image points of 2xN, Nx2, 3xN or Nx3 size (where N is number of points). Multi-channel 1xN or Nx1 array is also acceptable. The point coordinates should be floating-point (single or double precision) </param>
            <param name="points2">Array of the second image points of the same size and format as points1</param>
            <param name="fundamental_matrix">The output fundamental matrix or matrices. The size should be 3x3 or 9x3 (7-point method may return up to 3 matrices).</param>
            <param name="method">Method for computing the fundamental matrix </param>
            <param name="param1"></param>
            <param name="param2"></param>
            <param name="status"></param>
            <returns>the number of fundamental matrices found (1 or 3) and 0, if no matrix is found. </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindExtrinsicCameraParams2(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvFindExtrinsicCameraParams2 estimates extrinsic camera parameters using known intrinsic parameters and and extrinsic parameters for each view. The coordinates of 3D object points and their correspondent 2D projections must be specified. This function also minimizes back-projection error
            </summary>
            <param name="object_points">The array of object points, 3xN or Nx3, where N is the number of points in the view</param>
            <param name="image_points">The array of corresponding image points, 2xN or Nx2, where N is the number of points in the view</param>
            <param name="intrinsic_matrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. </param>
            <param name="distortion_coeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2]. If it is NULL, all distortion coefficients are considered 0's.</param>
            <param name="rotation_vector">The output 3x1 or 1x3 rotation vector (compact representation of a rotation matrix, see cvRodrigues2). </param>
            <param name="translation_vector">The output 3x1 or 1x3 translation vector</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalibrateCamera2(System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.MCvSize,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            The function CalibrateCamera2 Finds intrinsic and extrinsic camera parameters using calibration pattern
            </summary>
            <param name="object_points">The joint matrix of object points, 3xN or Nx3, where N is the total number of points in all views.</param>
            <param name="image_points">The joint matrix of corresponding image points, 2xN or Nx2, where N is the total number of points in all views.</param>
            <param name="point_counts">Vector containing numbers of points in each particular view, 1xM or Mx1, where M is the number of a scene views.</param>
            <param name="image_size">Size of the image, used only to initialize intrinsic camera matrix.</param>
            <param name="intrinsic_matrix">The output camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS and/or CV_CALIB_FIX_ASPECT_RATION are specified, some or all of fx, fy, cx, cy must be initialized.</param>
            <param name="distortion_coeffs">The output 4x1 or 1x4 vector of distortion coefficients [k1, k2, p1, p2].</param>
            <param name="rotation_vectors">The output 3xM or Mx3 array of rotation vectors (compact representation of rotation matrices, see cvRodrigues2).</param>
            <param name="translation_vectors">The output 3xM or Mx3 array of translation vectors.</param>
            <param name="flags">Different flags, may be 0 or combination of the following values:
            CV_CALIB_USE_INTRINSIC_GUESS(0x01) - intrinsic_matrix contains valid initial values of fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image center (image_size is used here), and focal distances are computed in some least-squares fashion. Note, that if intrinsic parameters are known, there is no need to use this function. Use cvFindExtrinsicCameraParams2 instead.
            CV_CALIB_FIX_PRINCIPAL_POINT(0x04) - The principal point is not changed during the global optimization, it stays at the center and at the other location specified (when CV_CALIB_USE_INTRINSIC_GUESS is set as well).
            CV_CALIB_FIX_ASPECT_RATIO(0x02) - The optimization procedure consider only one of fx and fy as independent variable and keeps the aspect ratio fx/fy the same as it was set initially in intrinsic_matrix. In this case the actual initial values of (fx, fy) are either taken from the matrix (when CV_CALIB_USE_INTRINSIC_GUESS is set) or estimated somehow (in the latter case fx, fy may be set to arbitrary values, only their ratio is used).
            CV_CALIB_ZERO_TANGENT_DIST(0x08) - Tangential distortion coefficients are set to zeros and do not change during the optimization.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvUndistort2(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvUndistort2 transforms the image to compensate radial and tangential lens distortion. The camera matrix and distortion parameters can be determined using cvCalibrateCamera2. For every pixel in the output image the function computes coordinates of the corresponding location in the input image using the formulae in the section beginning. Then, the pixel value is computed using bilinear interpolation. If the resolution of images is different from what was used at the calibration stage, fx, fy, cx and cy need to be adjusted appropriately, while the distortion coefficients remain the same.
            </summary>
            <param name="src">The input (distorted) image</param>
            <param name="dst">The output (corrected) image</param>
            <param name="intrinsic_matrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1].</param>
            <param name="distortion_coeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2].</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvProjectPoints2(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvProjectPoints2 computes projections of 3D points to the image plane given intrinsic and extrinsic camera parameters. Optionally, the function computes jacobians - matrices of partial derivatives of image points as functions of all the input parameters w.r.t. the particular parameters, intrinsic and/or extrinsic. The jacobians are used during the global optimization in cvCalibrateCamera2 and cvFindExtrinsicCameraParams2. The function itself is also used to compute back-projection error for with current intrinsic and extrinsic parameters.
            Note, that with intrinsic and/or extrinsic parameters set to special values, the function can be used to compute just extrinsic transformation or just intrinsic transformation (i.e. distortion of a sparse set of points). 
            </summary>
            <param name="object_points">The array of object points, 3xN or Nx3, where N is the number of points in the view</param>
            <param name="rotation_vector">The rotation vector, 1x3 or 3x1</param>
            <param name="translation_vector">The translation vector, 1x3 or 3x1</param>
            <param name="intrinsic_matrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. </param>
            <param name="distortion_coeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2]. If it is NULL, all distortion coefficients are considered 0's</param>
            <param name="image_points">The output array of image points, 2xN or Nx2, where N is the total number of points in the view</param>
            <param name="dpdrot">Optional Nx3 matrix of derivatives of image points with respect to components of the rotation vector</param>
            <param name="dpdt">Optional Nx3 matrix of derivatives of image points w.r.t. components of the translation vector</param>
            <param name="dpdf">Optional Nx2 matrix of derivatives of image points w.r.t. fx and fy</param>
            <param name="dpdc">Optional Nx2 matrix of derivatives of image points w.r.t. cx and cy</param>
            <param name="dpddist">Optional Nx4 matrix of derivatives of image points w.r.t. distortion coefficients</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvComputeCorrespondEpilines(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            For every point in one of the two images of stereo-pair the function cvComputeCorrespondEpilines finds equation of a line that contains the corresponding point (i.e. projection of the same 3D point) in the other image. Each line is encoded by a vector of 3 elements l=[a,b,c]T, so that: 
            lT*[x, y, 1]T=0, or
            a*x + b*y + c = 0
            From the fundamental matrix definition (see cvFindFundamentalMatrix discussion), line l2 for a point p1 in the first image (which_image=1) can be computed as: 
            l2=F*p1and the line l1 for a point p2 in the second image (which_image=1) can be computed as: 
            l1=FT*p2Line coefficients are defined up to a scale. They are normalized (a2+b2=1) are stored into correspondent_lines
            </summary>
            <param name="points">The input points. 2xN, Nx2, 3xN or Nx3 array (where N number of points). Multi-channel 1xN or Nx1 array is also acceptable.</param>
            <param name="which_image">Index of the image (1 or 2) that contains the points</param>
            <param name="fundamental_matrix">Fundamental matrix </param>
            <param name="correspondent_lines">Computed epilines, 3xN or Nx3 array </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvConvertPointsHomogenious(System.IntPtr,System.IntPtr)">
            <summary>
            The function cvConvertPointsHomogenious converts 2D or 3D points from/to homogenious coordinates, or simply copies or transposes the array. In case if the input array dimensionality is larger than the output, each point coordinates are divided by the last coordinate
            </summary>
            <param name="src">The input point array, 2xN, Nx2, 3xN, Nx3, 4xN or Nx4 (where N is the number of points). Multi-channel 1xN or Nx1 array is also acceptable</param>
            <param name="dst">The output point array, must contain the same number of points as the input; The dimensionality must be the same, 1 less or 1 more than the input, and also within 2..4.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMeanShift(System.IntPtr,Emgu.CV.MCvRect,Emgu.CV.MCvTermCriteria,System.IntPtr)">
            <summary>
            The function cvMeanShift iterates to find the object center given its back projection and initial position of search window. The iterations are made until the search window center moves by less than the given value and/or until the function has done the maximum number of iterations. 
            </summary>
            <param name="prob_image">Back projection of object histogram</param>
            <param name="window">Initial search window</param>
            <param name="criteria">Criteria applied to determine when the window search should be finished. </param>
            <param name="comp">Resultant structure that contains converged search window coordinates (comp->rect field) and sum of all pixels inside the window (comp->area field). </param>
            <returns>the number of iterations made</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCamShift(System.IntPtr,Emgu.CV.MCvRect,Emgu.CV.MCvTermCriteria,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvCamShift implements CAMSHIFT object tracking algrorithm ([Bradski98]). First, it finds an object center using cvMeanShift and, after that, calculates the object size and orientation. 
            </summary>
            <param name="prob_image">Back projection of object histogram </param>
            <param name="window">Initial search window</param>
            <param name="criteria">Criteria applied to determine when the window search should be finished</param>
            <param name="comp">Resultant structure that contains converged search window coordinates (comp->rect field) and sum of all pixels inside the window (comp->area field).</param>
            <param name="box">Circumscribed box for the object. If not NULL, contains object size and orientation</param>
            <returns>number of iterations made within cvMeanShift</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMatchTemplate(System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.TM_TYPE)">
            <summary>
            The function cvMatchTemplate is similiar to cvCalcBackProjectPatch. It slids through image, compares overlapped patches of size w×h with templ using the specified method and stores the comparison results to result
            </summary>
            <param name="image">Image where the search is running. It should be 8-bit or 32-bit floating-point</param>
            <param name="templ">Searched template; must be not greater than the source image and the same data type as the image</param>
            <param name="result">A map of comparison results; single-channel 32-bit floating-point. If image is W×H and templ is w×h then result must be W-w+1×H-h+1.</param>
            <param name="method">Specifies the way the template must be compared with image regions </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSnakeImage(System.IntPtr,System.IntPtr,System.Int32,System.Single[],System.Single[],System.Single[],System.Int32,Emgu.CV.MCvSize,Emgu.CV.MCvTermCriteria,System.Int32)">
            <summary>
            The function cvSnakeImage updates snake in order to minimize its total energy that is a sum of internal energy that depends on contour shape (the smoother contour is, the smaller internal energy is) and external energy that depends on the energy field and reaches minimum at the local energy extremums that correspond to the image edges in case of image gradient.
            </summary>
            <param name="image">The source image or external energy field</param>
            <param name="points">Seq points (snake). </param>
            <param name="length">Number of points in the contour</param>
            <param name="alpha">Weight[s] of continuity energy, single float or array of length floats, one per each contour point</param>
            <param name="beta">Weight[s] of curvature energy, similar to alpha</param>
            <param name="gamma">Weight[s] of image energy, similar to alpha</param>
            <param name="coeff_usage">Variant of usage of the previous three parameters: 
            CV_VALUE indicates that each of alpha, beta, gamma is a pointer to a single value to be used for all points; 
            CV_ARRAY indicates that each of alpha, beta, gamma is a pointer to an array of coefficients different for all the points of the snake. All the arrays must have the size equal to the contour size.
            </param>
            <param name="win">Size of neighborhood of every point used to search the minimum, both win.width and win.height must be odd</param>
            <param name="criteria">Termination criteria</param>
            <param name="calc_gradient">Gradient flag. If not 0, the function calculates gradient magnitude for every image pixel and consideres it as the energy field, otherwise the input image itself is considered</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFitLine(System.IntPtr,Emgu.CV.CvEnum.DIST_TYPE,System.Double,System.Double,System.Double,System.IntPtr)">
            <summary>
            The function cvFitLine fits line to 2D or 3D point set 
            </summary>
            <param name="points">Sequence or array of 2D or 3D points with 32-bit integer or floating-point coordinates</param>
            <param name="dist_type">The distance used for fitting </param>
            <param name="param">Numerical parameter (C) for some types of distances, if 0 then some optimal value is chosen</param>
            <param name="reps">Sufficient accuracy for radius (distance between the coordinate origin and the line),  0.01 would be a good default</param>
            <param name="aeps">Sufficient accuracy for angle, 0.01 would be a good default</param>
            <param name="line">The output line parameters. In case of 2d fitting it is array of 4 floats (vx, vy, x0, y0) where (vx, vy) is a normalized vector collinear to the line and (x0, y0) is some point on the line. In case of 3D fitting it is array of 6 floats (vx, vy, vz, x0, y0, z0) where (vx, vy, vz) is a normalized vector collinear to the line and (x0, y0, z0) is some point on the line.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFitEllipse2(System.IntPtr)">
            <summary>
            The function cvFitEllipse calculates ellipse that fits best (in least-squares sense) to a set of 2D points. The meaning of the returned structure fields is similar to those in cvEllipse except that size stores the full lengths of the ellipse axises, not half-lengths
            </summary>
            <param name="points">Sequence or array of points</param>
            <returns>The ellipse that fits best (in least-squares sense) to a set of 2D points</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateStructuringElementEx(System.Int32,System.Int32,System.Int32,System.Int32,Emgu.CV.CvEnum.CV_ELEMENT_SHAPE,System.Int32[0:,0:])">
            <summary>
            The function cvCreateStructuringElementEx creates an structuring element.
            </summary>
            <param name="cols">Number of columns in the structuring element.</param>
            <param name="rows">Number of rows in the structuring element.</param>
            <param name="anchorX">Relative horizontal offset of the anchor point.</param>
            <param name="anchorY">Relative vertical offset of the anchor point.</param>
            <param name="shape">Shape of the structuring element.</param>
            <param name="values">
            Pointer to the structuring element data, representing row-by-row scanning of the element matrix.
            Non-zero values indicate points that belong to the element.
            If the pointer is NULL, then all values are considered non-zero, that is, the element is of a rectangular shape.
            This parameter is considered only if the shape is CV_SHAPE_CUSTOM.
            </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseStructuringElement(System.IntPtr@)">
            <summary>
            The function cvReleaseStructuringElement releases the structuring element.
            </summary>
            <param name="ppElement">Pointer to the deallocated structuring element.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMorphologyEx(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.CV_MORPH_OP,System.Int32)">
            <summary>
            The function cvMorphologyEx performs advanced morphological transformations.
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image.</param>
            <param name="temp">
            Temporary image, required in some cases.
            The temporary image temp is required for morphological gradient and, in case of in-place operation, for "top hat" and "black hat".
            </param>
            <param name="element">Structuring element.</param>
            <param name="operation">Type of morphological operation.</param>
            <param name="iterations">Number of times erosion and dilation are applied.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateHist(System.Int32,System.IntPtr,System.Int32,System.IntPtr[],System.Int32)">
            <summary>
            The function cvCreateHist creates a histogram of the specified size and returns the pointer to the created histogram. If the array ranges is 0, the histogram bin ranges must be specified later via The function cvSetHistBinRanges, though cvCalcHist and cvCalcBackProject may process 8-bit images without setting bin ranges, they assume equally spaced in 0..255 bins
            </summary>
            <param name="dims">Number of histogram dimensions</param>
            <param name="sizes">Array of histogram dimension sizes</param>
            <param name="type">Histogram representation format: CV_HIST_ARRAY means that histogram data is represented as an multi-dimensional dense array CvMatND; CV_HIST_SPARSE means that histogram data is represented as a multi-dimensional sparse array CvSparseMat</param>
            <param name="ranges">Array of ranges for histogram bins. Its meaning depends on the uniform parameter value. The ranges are used for when histogram is calculated or backprojected to determine, which histogram bin corresponds to which value/tuple of values from the input image[s]. </param>
            <param name="uniform">Uniformity flag; if not 0, the histogram has evenly spaced bins and for every 0&lt;=i&lt;cDims ranges[i] is array of two numbers: lower and upper boundaries for the i-th histogram dimension. The whole range [lower,upper] is split then into dims[i] equal parts to determine i-th input tuple value ranges for every histogram bin. And if uniform=0, then i-th element of ranges array contains dims[i]+1 elements: lower0, upper0, lower1, upper1 == lower2, ..., upperdims[i]-1, where lowerj and upperj are lower and upper boundaries of i-th input tuple value for j-th bin, respectively. In either case, the input values that are beyond the specified range for a histogram bin, are not counted by cvCalcHist and filled with 0 by cvCalcBackProject</param>
            <returns>A pointer to the histogram</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetSpatialMoment(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            The function cvGetSpatialMoment retrieves the spatial moment, which in case of image moments is defined as:
            Mx_order,y_order=sumx,y(I(x,y)•xx_order•yy_order)
            where I(x,y) is the intensity of the pixel (x, y). 
            </summary>
            <param name="moments">The moment state</param>
            <param name="x_order">x order of the retrieved moment, x_order &gt;= 0. </param>
            <param name="y_order">y order of the retrieved moment, y_order &gt;= 0 and x_order + y_order &lt;= 3</param>
            <returns>The spatial moment</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetCentralMoment(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            The function cvGetCentralMoment retrieves the central moment, which in case of image moments is defined as:
            μx_order,y_order=sumx,y(I(x,y)•(x-xc)x_order•(y-yc)y_order),
            where xc=M10/M00, yc=M01/M00 - coordinates of the gravity center
            </summary>
            <param name="moments">Pointer to the moment state structure</param>
            <param name="x_order">x order of the retrieved moment, x_order &gt;= 0.</param>
            <param name="y_order">y order of the retrieved moment, y_order &gt;= 0 and x_order + y_order &lt;= 3</param>
            <returns>The center moment</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRodrigues2(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvRodrigues2 converts a rotation vector to rotation matrix or vice versa. Rotation vector is a compact representation of rotation matrix. Direction of the rotation vector is the rotation axis and the length of the vector is the rotation angle around the axis. The rotation matrix R, corresponding to the rotation vector r.
            </summary>
            <param name="src">The input rotation vector (3x1 or 1x3) or rotation matrix (3x3). </param>
            <param name="dst">The output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively</param>
            <param name="jacobian">Optional output Jacobian matrix, 3x9 or 9x3 - partial derivatives of the output array components w.r.t the input array components</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetHuMoments(System.IntPtr,System.IntPtr)">
            <summary>
            The function cvGetHuMoments calculates seven Hu invariants
            </summary>
            <param name="moments">Pointer to the moment state structure</param>
            <param name="hu_moments">Pointer to Hu moments structure.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateKalman(System.Int32,System.Int32,System.Int32)">
            <summary>
            The function cvCreateKalman allocates CvKalman and all its matrices and initializes them somehow. 
            </summary>
            <param name="dynam_params">dimensionality of the state vector</param>
            <param name="measure_params">dimensionality of the measurement vector </param>
            <param name="control_params">dimensionality of the control vector </param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseKalman(System.IntPtr@)">
            <summary>
            The function cvReleaseKalman releases the structure CvKalman and all underlying matrices
            </summary>
            <param name="kalman">reference of the pointer to the Kalman filter structure.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvUpdateMotionHistory(System.IntPtr,System.IntPtr,System.Double,System.Double)">
            <summary>
            The function cvUpdateMotionHistory updates the motion history image as following:
            mhi(x,y)=timestamp  if silhouette(x,y)!=0
                    0          if silhouette(x,y)=0 and mhi(x,y)&lt;timestamp-duration
                    mhi(x,y)   otherwise
            That is, MHI pixels where motion occurs are set to the current timestamp, while the pixels where motion happened far ago are cleared. 
            </summary>
            <param name="silhouette">Silhouette mask that has non-zero pixels where the motion occurs. </param>
            <param name="mhi">Motion history image, that is updated by the function (single-channel, 32-bit floating-point) </param>
            <param name="timestamp">Current time in milliseconds or other units. </param>
            <param name="duration">Maximal duration of motion track in the same units as timestamp. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcMotionGradient(System.IntPtr,System.IntPtr,System.IntPtr,System.Double,System.Double,System.Int32)">
             <summary>
             The function cvCalcMotionGradient calculates the derivatives Dx and Dy of mhi and then calculates gradient orientation as:
            orientation(x,y)=arctan(Dy(x,y)/Dx(x,y))
            where both Dx(x,y)' and Dy(x,y)' signs are taken into account (as in cvCartToPolar function). After that mask is filled to indicate where the orientation is valid (see delta1 and delta2 description). 
             </summary>
             <param name="mhi">Motion history image</param>
             <param name="mask">Mask image; marks pixels where motion gradient data is correct. Output parameter.</param>
             <param name="orientation">Motion gradient orientation image; contains angles from 0 to ~360°. </param>
             <param name="delta1">The function finds minimum (m(x,y)) and maximum (M(x,y)) mhi values over each pixel (x,y) neihborhood and assumes the gradient is valid only if min(delta1,delta2) &lt;= M(x,y)-m(x,y) &lt;= max(delta1,delta2). </param>
             <param name="delta2">The function finds minimum (m(x,y)) and maximum (M(x,y)) mhi values over each pixel (x,y) neihborhood and assumes the gradient is valid only if min(delta1,delta2) &lt;= M(x,y)-m(x,y) &lt;= max(delta1,delta2).</param>
             <param name="aperture_size">Aperture size of derivative operators used by the function: CV_SCHARR, 1, 3, 5 or 7 (see cvSobel). </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCornerHarris(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Double)">
            <summary>
            The function cvCornerHarris runs the Harris edge detector on image. Similarly to cvCornerMinEigenVal and cvCornerEigenValsAndVecs, for each pixel it calculates 2x2 gradient covariation matrix M over block_size×block_size neighborhood. Then, it stores
            det(M) - k*trace(M)^2
            to the destination image. Corners in the image can be found as local maxima of the destination image.
            </summary>
            <param name="image">Input image</param>
            <param name="harris_responce">Image to store the Harris detector responces. Should have the same size as image </param>
            <param name="block_size">Neighborhood size </param>
            <param name="aperture_size">Aperture parameter for Sobel operator (see cvSobel). format. In the case of floating-point input format this parameter is the number of the fixed float filter used for differencing. </param>
            <param name="k">Harris detector free parameter.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvIntegral(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The function cvIntegral calculates one or more integral images for the source image 
            Using these integral images, one may calculate sum, mean, standard deviation over arbitrary up-right or rotated rectangular region of the image in a constant time.
            It makes possible to do a fast blurring or fast block correlation with variable window size etc. In case of multi-channel images sums for each channel are accumulated independently. 
            </summary>
            <param name="image">The source image, W×H, 8-bit or floating-point (32f or 64f) image.</param>
            <param name="sum">The integral image, W+1×H+1, 32-bit integer or double precision floating-point (64f). </param>
            <param name="sqsum">The integral image for squared pixel values, W+1×H+1, double precision floating-point (64f). </param>
            <param name="tilted_sum">The integral for the image rotated by 45 degrees, W+1×H+1, the same data type as sum.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cv2DRotationMatrix(Emgu.CV.MCvPoint2D32f,System.Double,System.Double,System.IntPtr)">
            <summary>
            The function cv2DRotationMatrix calculates rotation matrix
            </summary>
            <param name="center">Center of the rotation in the source image. </param>
            <param name="angle">The rotation angle in degrees. Positive values mean couter-clockwise rotation (the coordiate origin is assumed at top-left corner).</param>
            <param name="scale">Isotropic scale factor</param>
            <param name="map_matrix">Pointer to the destination 2×3 matrix</param>
            <returns>Pointer to the destination 2×3 matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcHist(System.IntPtr[],System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            The function cvCalcHist calculates the histogram of one or more single-channel images. The elements of a tuple that is used to increment a histogram bin are taken at the same location from the corresponding input images.
            </summary>
            <param name="image">Source images (though, you may pass CvMat** as well), all are of the same size and type</param>
            <param name="hist">Pointer to the histogram</param>
            <param name="accumulate">Accumulation flag. If it is set, the histogram is not cleared in the beginning. This feature allows user to compute a single histogram from several images, or to update the histogram online</param>
            <param name="mask">The operation mask, determines what pixels of the source images are counted</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcArrBackProject(System.IntPtr[],System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="image"></param>
            <param name="back_project"></param>
            <param name="hist"></param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcBackProject(System.IntPtr[],System.IntPtr,System.IntPtr)">
            <summary>
            The function cvCalcBackProject calculates the back project of the histogram. For each tuple of pixels at the same position of all input single-channel images the function puts the value of the histogram bin, corresponding to the tuple, to the destination image. In terms of statistics, the value of each output image pixel is probability of the observed tuple given the distribution (histogram). For example, to find a red object in the picture, one may do the following: 
            1. Calculate a hue histogram for the red object assuming the image contains only this object. The histogram is likely to have a strong maximum, corresponding to red color. 
            2. Calculate back projection of a hue plane of input image where the object is searched, using the histogram. Threshold the image. 
            3. Find connected components in the resulting picture and choose the right component using some additional criteria, for example, the largest connected component. 
            That is the approximate algorithm of Camshift color object tracker, except for the 3rd step, instead of which CAMSHIFT algorithm is used to locate the object on the back projection given the previous object position. 
            </summary>
            <param name="image">Source images (though you may pass CvMat** as well), all are of the same size and type </param>
            <param name="back_project">Destination back projection image of the same type as the source images</param>
            <param name="hist">Histogram</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseHist(System.IntPtr@)">
            <summary>
            The function cvReleaseHist releases the histogram (header and the data). The pointer to histogram is cleared by the function. If *hist pointer is already NULL, the function does nothing.
            </summary>
            <param name="hist">Double pointer to the released histogram</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDistTransform(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.DIST_TYPE,System.Int32,System.Single[],System.IntPtr)">
            <summary>
            The function cvDistTransform calculates distance to closest zero pixel for all non-zero pixels of source image
            </summary>
            <param name="src">Source 8-bit single-channel (binary) image.</param>
            <param name="dst">Output image with calculated distances (32-bit floating-point, single-channel). </param>
            <param name="distance_type">Type of distance; can be CV_DIST_L1, CV_DIST_L2, CV_DIST_C or CV_DIST_USER. </param>
            <param name="mask_size">Size of distance transform mask; can be 3 or 5.
            In case of CV_DIST_L1 or CV_DIST_C the parameter is forced to 3, because 3×3 mask gives the same result as 5×5 yet it is faster.</param>
            <param name="user_mask">User-defined mask in case of user-defined distance.
            It consists of 2 numbers (horizontal/vertical shift cost, diagonal shift cost) in case of 3×3 mask
            and 3 numbers (horizontal/vertical shift cost, diagonal shift cost, knights move cost) in case of 5×5 mask.</param>
            <param name="labels">The optional output 2d array of labels of integer type and the same size as src and dst.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFloodFill(System.IntPtr,Emgu.CV.MCvPoint,Emgu.CV.MCvScalar,Emgu.CV.MCvScalar,Emgu.CV.MCvScalar,Emgu.CV.MCvConnectedComp,System.Int32,System.IntPtr)">
            <summary>
            The function cvFloodFill fills a connected component with given color.
            </summary>
            <param name="src">Input 1- or 3-channel, 8-bit or floating-point image. It is modified by the function unless CV_FLOODFILL_MASK_ONLY flag is set.</param>
            <param name="seed_point">The starting point.</param>
            <param name="new_val">New value of repainted domain pixels.</param>
            <param name="lo_diff">Maximal lower brightness/color difference
            between the currently observed pixel and one of its neighbor belong to the component
            or seed pixel to add the pixel to component.
            In case of 8-bit color images it is packed value.</param>
            <param name="up_diff">Maximal upper brightness/color difference
            between the currently observed pixel and one of its neighbor belong to the component
            or seed pixel to add the pixel to component.
            In case of 8-bit color images it is packed value.</param>
            <param name="comp">Pointer to structure the function fills with the information about the repainted domain.</param>
            <param name="flags">The operation flags.
            Lower bits contain connectivity value, 4 (by default) or 8, used within the function.
            Connectivity determines which neighbors of a pixel are considered.
            Upper bits can be 0 or combination of the following flags:
            CV_FLOODFILL_FIXED_RANGE - if set the difference between the current pixel and seed pixel is considered,
            otherwise difference between neighbor pixels is considered (the range is floating).
            CV_FLOODFILL_MASK_ONLY - if set, the function does not fill the image (new_val is ignored),
            but the fills mask (that must be non-NULL in this case). </param>
            <param name="mask">Operation mask,
            should be singe-channel 8-bit image, 2 pixels wider and 2 pixels taller than image.
            If not NULL, the function uses and updates the mask, so user takes responsibility of initializing mask content.
            Floodfilling can't go across non-zero pixels in the mask, for example, an edge detector output can be used as a mask to stop filling at edges.
            Or it is possible to use the same mask in multiple calls to the function to make sure the filled area do not overlap.
            Note: because mask is larger than the filled image, pixel in mask that corresponds to (x,y) pixel in image will have coordinates (x+1,y+1).</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateCameraCapture(System.Int32)">
            <summary>
            The function cvCreateCameraCapture allocates and initialized the CvCapture structure for reading a video stream from the camera. Currently two camera interfaces can be used on Windows: Video for Windows (VFW) and Matrox Imaging Library (MIL); and two on Linux: V4L and FireWire (IEEE1394). 
            </summary>
            <param name="index">Index of the camera to be used. If there is only one camera or it does not matter what camera to use -1 may be passed</param>
            <returns>Pointer to the capture structure</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateFileCapture(System.String)">
             <summary>
             The function cvCreateFileCapture allocates and initialized the CvCapture structure for reading the video stream from the specified file. 
            After the allocated structure is not used any more it should be released by cvReleaseCapture function. 
             </summary>
             <param name="filename">Name of the video file</param>
             <returns>Pointer to the capture structure</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseCapture(System.IntPtr@)">
            <summary>
            The function cvReleaseCapture releases the CvCapture structure allocated by cvCreateFileCapture or cvCreateCameraCapture
            </summary>
            <param name="capture">pointer to video capturing structure. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvQueryFrame(System.IntPtr)">
            <summary>
            The function cvQueryFrame grabs a frame from camera or video file, decompresses and returns it. This function is just a combination of cvGrabFrame and cvRetrieveFrame in one call. The returned image should not be released or modified by user. 
            </summary>
            <param name="capture">video capturing structure</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetCaptureProperty(System.IntPtr,Emgu.CV.CvEnum.CAP_PROP)">
            <summary>
            The function cvGetCaptureProperty retrieves the specified property of camera or video file
            </summary>
            <param name="capture">video capturing structure</param>
            <param name="prop">property identifier</param>
            <returns> the specified property of camera or video file</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvLoadImage(System.String,Emgu.CV.CvEnum.LOAD_IMAGE_TYPE)">
            <summary>
            The function cvLoadImage loads an image from the specified file and returns the pointer to the loaded image. Currently the following file formats are supported: 
            Windows bitmaps - BMP, DIB; 
            JPEG files - JPEG, JPG, JPE; 
            Portable Network Graphics - PNG; 
            Portable image format - PBM, PGM, PPM; 
            Sun rasters - SR, RAS; 
            TIFF files - TIFF, TIF; 
            OpenEXR HDR images - EXR; 
            JPEG 2000 images - jp2. 
            </summary>
            <param name="filename">The name of the file to be loaded</param>
            <param name="load_type"></param>
            <returns>The loaded image</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSaveImage(System.String,System.IntPtr)">
            <summary>
            The function cvSaveImage saves the image to the specified file. The image format is chosen depending on the filename extension, see cvLoadImage. Only 8-bit single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function. If the format, depth or channel order is different, use cvCvtScale and cvCvtColor to convert it before saving, or use universal cvSave to save the image to XML or YAML format
            </summary>
            <param name="filename">The name of the file to be saved to</param>
            <param name="image">The image to be saved</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvNamedWindow(System.String)">
             <summary>
             The function cvNamedWindow creates a window which can be used as a placeholder for images and trackbars. Created windows are reffered by their names. 
            If the window with such a name already exists, the function does nothing.
             </summary>
             <param name="name">Name of the window which is used as window identifier and appears in the window caption</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvWaitKey(System.Int32)">
            <summary>
            The function cvWaitKey waits for key event infinitely (delay &lt;= 0) or for "delay" milliseconds. 
            </summary>
            <param name="delay">Delay in milliseconds.</param>
            <returns>The code of the pressed key or -1 if no key were pressed until the specified timeout has elapsed</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvShowImage(System.String,System.IntPtr)">
            <summary>
            The function cvShowImage shows the image in the specified window
            </summary>
            <param name="name">Name of the window</param>
            <param name="image">Image to be shown</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDestroyWindow(System.String)">
            <summary>
            The function cvDestroyWindow destroys the window with a given name
            </summary>
            <param name="name">Name of the window to be destroyed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateVideoWriter(System.String,System.Int32,System.Double,Emgu.CV.MCvSize,System.Boolean)">
            <summary>
            The function cvCreateVideoWriter creates video writer structure.
            </summary>
            <param name="filename">Name of the output video file.</param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, CV_FOURCC('P','I','M','1') is MPEG-1 codec, CV_FOURCC('M','J','P','G') is motion-jpeg codec etc.</param>
            <param name="fps">Framerate of the created video stream. </param>
            <param name="frame_size">Size of video frames.</param>
            <param name="is_color">If it is not false, the encoder will expect and encode color frames, otherwise it will work with grayscale frames </param>
            <returns>the video writer</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseVideoWriter(System.IntPtr@)">
            <summary>
            The function cvReleaseVideoWriter finishes writing to video file and releases the structure.
            </summary>
            <param name="writer">pointer to video file writer structure</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvWriteFrame(System.IntPtr,System.IntPtr)">
            <summary>
            The function cvWriteFrame writes/appends one frame to video file.
            </summary>
            <param name="writer">video writer structure.</param>
            <param name="image">the written frame</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvcamGetCamerasCount">
            <summary>
            Get the number of cameras available
            </summary>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CV_MAKETYPE(System.Int32,System.Int32)">
            <summary>
            This function performs the same as CV_MAKETYPE macro
            </summary>
            <param name="depth"></param>
            <param name="cn"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CV_FOURCC(System.Char,System.Char,System.Char,System.Char)">
            <summary>
            Generate 4-character code of codec used to compress the frames. For example, CV_FOURCC('P','I','M','1') is MPEG-1 codec, CV_FOURCC('M','J','P','G') is motion-jpeg codec etc.
            </summary>
            <param name="c1"></param>
            <param name="c2"></param>
            <param name="c3"></param>
            <param name="c4"></param>
            <returns></returns>
        </member>
        <member name="T:Emgu.CV.CvInvoke.CvErrorCallback">
            <summary>
            The Error callback that can be registered by cvRedirectError
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the souce where error is encountered</param>
            <param name="userData">Arbitrary pointer that is transparetly passed to the error handler.</param>
            <returns></returns>
        </member>
        <member name="T:Emgu.CV.RotationVector">
            <summary>
            A 3D rotation matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.RotationVector.#ctor">
            <summary>
            Create a (3x1) 3D rotation vector.
            </summary>
        </member>
        <member name="M:Emgu.CV.RotationVector.#ctor(System.Single[])">
            <summary>
            Create a rotation vector using the specific values
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:Emgu.CV.RotationVector.RotationMatrix">
            <summary>
            Get or Set the (3x3) rotation matrix represented by this rotation vector
            </summary>
        </member>
        <member name="T:Emgu.CV.ColorInfoAttribute">
            <summary>
            Attributes used to specify color information
            </summary>
        </member>
        <member name="F:Emgu.CV.ColorInfoAttribute._conversionCodeName">
            <summary>
            The code which is used for color conversion
            </summary>
        </member>
        <member name="M:Emgu.CV.ColorInfoAttribute.#ctor">
            <summary>
            The code which is used for color conversion
            </summary>
        </member>
        <member name="P:Emgu.CV.ColorInfoAttribute.ConversionCodeName">
            <summary>
            The code which is used for color conversion
            </summary>
        </member>
        <member name="T:Emgu.CV.ICapture">
            <summary> The interface that is used for WCF to provide a image capture service</summary>
        </member>
        <member name="M:Emgu.CV.ICapture.QueryFrame">
            <summary> Capture a Bgr image frame </summary>
            <returns> A Bgr image frame</returns>
        </member>
        <member name="M:Emgu.CV.ICapture.QuerySmallFrame">
            <summary> Capture a Bgr image frame that is half width and half heigh</summary>
            <returns> A Bgr image frame that is half width and half height</returns>
        </member>
        <member name="T:Emgu.CV.MCvMat">
            <summary>
            Managed structure equivalent to CvMat
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMat.type">
            <summary>
            CvMat signature (CV_MAT_MAGIC_VAL), element type and flags
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMat.step">
            <summary>
            full row length in bytes
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMat.refcount">
            <summary>
            underlying data reference counter
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMat.hdr_refcount">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMat.data">
            <summary>
            data pointers
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMat.rows">
            <summary>
            number of rows
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMat.cols">
            <summary>
            number of columns
            </summary>
        </member>
        <member name="P:Emgu.CV.MCvMat.width">
            <summary>
            Width
            </summary>
        </member>
        <member name="P:Emgu.CV.MCvMat.height">
            <summary>
            Height
            </summary>
        </member>
        <member name="T:Emgu.CV.MCvFont">
            <summary>
            Managed structure equivalent to CvFont
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvFont.font_face">
            <summary>
             =CV_FONT_* 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvFont.ascii">
            <summary>
             font data and metrics 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvFont.greek">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvFont.cyrillic">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvFont.hscale">
            <summary>
            hscale
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvFont.vscale">
            <summary>
            vscale
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvFont.shear">
            <summary>
             slope coefficient: 0 - normal, >0 - italic 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvFont.thickness">
            <summary>
             letters thickness 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvFont.dx">
            <summary>
             horizontal interval between letters 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvFont.line_type">
            <summary>
            type of line
            </summary>
        </member>
        <member name="T:Emgu.CV.UI.ImageProperty">
            <summary>
            The control to display image properties
            </summary>
        </member>
        <member name="M:Emgu.CV.UI.ImageProperty.#ctor">
            <summary>
            Create a ImageProperty control
            </summary>
        </member>
        <member name="F:Emgu.CV.UI.ImageProperty.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:Emgu.CV.UI.ImageProperty.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Emgu.CV.UI.ImageProperty.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="P:Emgu.CV.UI.ImageProperty.ImageWidth">
            <summary>
            Set the width of the image
            </summary>
        </member>
        <member name="P:Emgu.CV.UI.ImageProperty.ImageHeight">
            <summary>
            Set the height of the image
            </summary>
        </member>
        <member name="P:Emgu.CV.UI.ImageProperty.TypeOfColor">
            <summary>
            Set the Type of the color
            </summary>
        </member>
        <member name="P:Emgu.CV.UI.ImageProperty.MousePositionOnImage">
            <summary>
            Set the mouse position over the image
            </summary>
        </member>
        <member name="P:Emgu.CV.UI.ImageProperty.ColorIntensity">
            <summary>
            Set the color intensity of the pixel on the image where is mouse is at
            </summary>
        </member>
        <member name="P:Emgu.CV.UI.ImageProperty.TypeOfDepth">
            <summary>
            Set the Depth of the image
            </summary>
        </member>
        <member name="P:Emgu.CV.UI.ImageProperty.OperationStackText">
            <summary>
            Set the description of the operation stack
            </summary>
        </member>
        <member name="P:Emgu.CV.UI.ImageProperty.FramesPerSecondText">
            <summary>
            Set the frame rate
            </summary>
        </member>
        <member name="T:Emgu.CV.Ycc">
            <summary> 
            Defines a Ycc color (YCrCb JPEG)
            </summary>
        </member>
        <member name="M:Emgu.CV.Ycc.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Ycc color using the specific values</summary>
            <param name="y"> The Y value for this color </param>
            <param name="cr"> The Cr value for this color </param>
            <param name="cb"> The Cb value for this color </param>
        </member>
        <member name="M:Emgu.CV.Ycc.#ctor">
            <summary> Create a Ycc color using the default values (0.0, 0.0, 0.0)</summary>
        </member>
        <member name="P:Emgu.CV.Ycc.Y">
            <summary> The intensity of the Y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Ycc.Cr">
            <summary> The intensity of the Cr color channel </summary>
        </member>
        <member name="P:Emgu.CV.Ycc.Cb">
            <summary> The intensity of the Cb color channel </summary>
        </member>
        <member name="T:Emgu.CV.Xyz">
            <summary> 
            Defines a Xyz color (CIE XYZ.Rec 709 with D65 white point)
            </summary>
        </member>
        <member name="M:Emgu.CV.Xyz.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Xyz color using the specific values</summary>
            <param name="z"> The z value for this color </param>
            <param name="y"> The y value for this color </param>
            <param name="x"> The x value for this color </param>
        </member>
        <member name="M:Emgu.CV.Xyz.#ctor">
            <summary> Create a Xyz color using the default values (0.0, 0.0, 0.0)</summary>
        </member>
        <member name="P:Emgu.CV.Xyz.X">
            <summary> The intensity of the z color channel </summary>
        </member>
        <member name="P:Emgu.CV.Xyz.Y">
            <summary> The intensity of the y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Xyz.Z">
            <summary> The intensity of the x color channel </summary>
        </member>
        <member name="T:Emgu.CV.TimedImage`2">
            <summary> The Image which contains time stamp which specified what time this image is created </summary>
        </member>
        <member name="T:Emgu.CV.Image`2">
            <summary>
            A wrapper for IplImage
            </summary>
            <typeparam name="C">ColorType type of this image</typeparam>
            <typeparam name="D">Depth of this image (either Byte or Single)</typeparam>
        </member>
        <member name="T:Emgu.CV.IImage">
            <summary>
            IImage interface
            </summary>
        </member>
        <member name="M:Emgu.CV.IImage._Not">
            <summary>
            Inplace compute the complement image
            </summary>
        </member>
        <member name="M:Emgu.CV.IImage._Min(System.Double)">
            <summary>
            Inplace compute the minimum of the image pixel with the specific value
            </summary>
            <param name="value">the minimun value</param>
        </member>
        <member name="M:Emgu.CV.IImage._Max(System.Double)">
            <summary>
            Inplace compute the maximum of the image pixel with the specific value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Emgu.CV.IImage._Erode(System.Int32)">
            <summary>
            Inplace perform Erode function for <paramref name="iterations"/>
            </summary>
            <param name="iterations">the number of iterations for erode</param>
        </member>
        <member name="M:Emgu.CV.IImage._Dilate(System.Int32)">
            <summary>
            Inplace perform Dilate function for <paramref name="iterations"/>
            </summary>
            <param name="iterations">the number of iterations for dilate</param>
        </member>
        <member name="M:Emgu.CV.IImage._RandUniform(System.UInt64,Emgu.CV.MCvScalar,Emgu.CV.MCvScalar)">
            <summary>
            Inplace fills Array with uniformly distributed random numbers
            </summary>
            <param name="seed">Seed for the random number generator</param>
            <param name="floorValue">the inclusive lower boundary of random numbers range</param>
            <param name="ceilingValue">the exclusive upper boundary of random numbers range</param>
        </member>
        <member name="M:Emgu.CV.IImage._RandNormal(System.UInt64,Emgu.CV.MCvScalar,Emgu.CV.MCvScalar)">
            <summary>
            Inplace fills Array with normally distributed random numbers
            </summary>
            <param name="seed">Seed for the random number generator</param>
            <param name="mean">the mean value of random numbers</param>
            <param name="std"> the standard deviation of random numbers</param>
        </member>
        <member name="M:Emgu.CV.IImage.PyrUp">
            <summary>
            The function cvPyrUp performs up-sampling step of Gaussian pyramid decomposition. 
            First it upsamples <i>this</i> image by injecting even zero rows and columns and then convolves 
            result with the specified filter multiplied by 4 for interpolation. 
            So the resulting image is four times larger than the source image.
            </summary>
            <returns> The upsampled image</returns>
        </member>
        <member name="M:Emgu.CV.IImage.PyrDown">
            <summary>
            The function PyrDown performs downsampling step of Gaussian pyramid decomposition. 
            First it convolves <i>this</i> image with the specified filter and then downsamples the image 
            by rejecting even rows and columns.
            </summary>
            <returns> The downsampled image</returns>
        </member>
        <member name="M:Emgu.CV.IImage.Laplace(System.Int32)">
             <summary>
             The function cvLaplace calculates Laplacian of the source image by summing second x- and y- derivatives calculated using Sobel operator:
             dst(x,y) = d2src/dx2 + d2src/dy2
             Specifying aperture_size=1 gives the fastest variant that is equal to convolving the image with the following kernel:
            
             |0  1  0|
             |1 -4  1|
             |0  1  0|
             </summary>
             <param name="apertureSize">Aperture size </param>
             <returns>The Laplacian of the image</returns>
        </member>
        <member name="M:Emgu.CV.IImage.Resize(System.Int32,System.Int32)">
            <summary>
             Scale the image to the specific size 
             </summary>
            <param name="width">The width of the returned image.</param>
            <param name="height">The height of the returned image.</param>
            <returns>The resized image</returns>
        </member>
        <member name="M:Emgu.CV.IImage.Resize(System.Double)">
            <summary>
             Scale the image to the specific size: width *= scale; height *= scale  
             </summary>
             <returns>The scaled image</returns>
        </member>
        <member name="M:Emgu.CV.IImage.Canny(Emgu.CV.MCvScalar,Emgu.CV.MCvScalar)">
            <summary> 
             Find the edges on this image and marked them in the returned image.
            </summary>
            <param name="thresh"> The threshhold to find initial segments of strong edges</param>
            <param name="threshLinking"> The threshold used for edge Linking</param>
            <returns> The edges found by the Canny edge detector</returns>
        </member>
        <member name="M:Emgu.CV.IImage.Sobel(System.Int32,System.Int32,System.Int32)">
            <summary>
            The function cvSobel calculates the image derivative by convolving the image with the appropriate kernel:
            dst(x,y) = dxorder+yodersrc/dxxorder昫yyorder |(x,y)
            The Sobel operators combine Gaussian smoothing and differentiation so the result is more or less robust to the noise. Most often, the function is called with (xorder=1, yorder=0, aperture_size=3) or (xorder=0, yorder=1, aperture_size=3) to calculate first x- or y- image derivative.
            </summary>
            <param name="xorder">Order of the derivative x</param>
            <param name="yorder">Order of the derivative y</param>
            <param name="apertureSize">Size of the extended Sobel kernel, must be 1, 3, 5 or 7. In all cases except 1, aperture_size 譨perture_size separable kernel will be used to calculate the derivative.</param>
            <returns>The result of the sobel edge detector</returns>
        </member>
        <member name="M:Emgu.CV.IImage.Flip(Emgu.CV.CvEnum.FLIP)">
            <summary> Return a filpped copy of the current image</summary>
            <param name="flipType">The type of the flipping</param>
            <returns> The flipped copy of <i>this</i> image </returns>
        </member>
        <member name="M:Emgu.CV.IImage.Rotate(System.Double,Emgu.CV.MCvScalar,System.Boolean)">
            <summary>
            Rotate the image the specified angle
            </summary>
            <param name="angle">The angle of rotation in degrees.</param>
            <param name="background">The color with wich to fill the background</param>
            <param name="crop">If set to true the image is cropped to its original size, possibly losing corners information. If set to false the result image has different size than original and all rotation information is preserved</param>
            <returns>The rotated image</returns>
        </member>
        <member name="M:Emgu.CV.IImage.DFT(Emgu.CV.CvEnum.CV_DXT,System.Int32)">
            <summary>
            performs forward or inverse transform of 1D or 2D floating-point array
            </summary>
            <param name="type">Transformation flags</param>
            <param name="nonzeroRows">Number of nonzero rows to in the source array (in case of forward 2d transform), or a number of rows of interest in the destination array (in case of inverse 2d transform). If the value is negative, zero, or greater than the total number of rows, it is ignored. The parameter can be used to speed up 2d convolution/correlation when computing them via DFT</param>
            <returns>The result of DFT</returns>
        </member>
        <member name="M:Emgu.CV.IImage.DCT(Emgu.CV.CvEnum.CV_DCT_TYPE)">
            <summary>
            performs forward or inverse transform of 2D floating-point image
            </summary>
            <param name="type">Transformation flags</param>
            <returns>The result of DCT</returns>
        </member>
        <member name="M:Emgu.CV.IImage.ToGray">
            <summary>
            Convert the current image to grayscale image
            </summary>
            <returns>The Grayscale image</returns>
        </member>
        <member name="M:Emgu.CV.IImage.ToSingle">
            <summary>
            Convert the current image to depth of Single
            </summary>
            <returns>The Single(floating point) image </returns>
        </member>
        <member name="M:Emgu.CV.IImage.ToByte">
            <summary>
            Convert the current image to depth of Byte
            </summary>
            <returns>The Byte image </returns>
        </member>
        <member name="M:Emgu.CV.IImage.GetColor(Emgu.CV.Point2D{System.Int32})">
            <summary>
            Obtain the color from the specific location on the image
            </summary>
            <param name="position">The location of the pixel</param>
            <returns>The color value on the specific <paramref name="position"/></returns>
        </member>
        <member name="M:Emgu.CV.IImage.Save(System.String)">
            <summary>
            Save the image to the specific <paramref name="fileName"/> 
            </summary>
            <param name="fileName">The file name of the image</param>
        </member>
        <member name="P:Emgu.CV.IImage.Bitmap">
            <summary>
            Convert this image into Bitmap 
            </summary>
            <returns></returns>
        </member>
        <member name="P:Emgu.CV.IImage.Width">
            <summary>
            The width of this image
            </summary>
        </member>
        <member name="P:Emgu.CV.IImage.Height">
            <summary>
            The height of this image
            </summary>
        </member>
        <member name="P:Emgu.CV.IImage.TypeOfColor">
            <summary>
            The type of color for this image
            </summary>
        </member>
        <member name="P:Emgu.CV.IImage.TypeOfDepth">
            <summary>
            The type fo depth for this image
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor">
            <summary>
            Create an Image of random color and one by one in size
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(`1[0:,0:,0:])">
            <summary>
            Create image from the specific multi-dimensional data, where the 1st dimesion is # of rows (height), the 2nd dimension is # cols (cols) and the 3rd dimension is the channel
            </summary>
            <param name="data">The multi-dimensional data where the 1st dimesion is # of rows (height), the 2nd dimension is # cols (cols) and the 3rd dimension is the channel </param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.String)">
            <summary>
            Read image from a file
            </summary>
            <param name="fileName">the name of the file that contains the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Drawing.Bitmap)">
            <summary>
            Obtain the image from the specific Bitmap
            </summary>
            <param name="bmp">The bitmap which will be converted to the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Int32,System.Int32,`0)">
            <summary>
            Create a blank Image of the specified width, height and color.
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="value">The initial color of the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a blank Image of the specified width and height. 
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AllocateData(System.Int32,System.Int32)">
            <summary>
            Allocate data for the array
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of columns</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(Emgu.CV.Image{Emgu.CV.Gray,`1}[])">
            <summary>
            Create a multi-channel image from multiple gray scale images
            </summary>
            <param name="channels">The image channels to be merged into a single image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Image`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serilization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">streaming context</param>
        </member>
        <member name="M:Emgu.CV.Image`2.SetValue(`0)">
            <summary>
            Set every pixel of the image to the specific color 
            </summary>
            <param name="color">The color to be set</param>
        </member>
        <member name="M:Emgu.CV.Image`2.SetValue(`0,Emgu.CV.Image{Emgu.CV.Gray,System.Byte})">
            <summary>
            Set every pixel of the image to the specific color, using a mask
            </summary>
            <param name="color">The color to be set</param>
            <param name="mask">The mask for setting pixels</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Clone(Emgu.CV.Image{Emgu.CV.Gray,System.Byte})">
            <summary> 
             Make a clone of the image using a mask, if ROI is set, only copy the ROI 
             </summary> 
            <returns> A clone of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Clone">
            <summary> Make a clone of the image, if ROI is set, only copy the ROI</summary>
            <returns> A clone of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Gray,System.Byte})">
            <summary>
            Copy the masked area of this image to destination
            </summary>
            <param name="dest">the destination to copy to</param>
            <param name="mask">the mask for copy</param>
        </member>
        <member name="M:Emgu.CV.Image`2.BlankClone">
            <summary> 
            Create an image of the same size
            </summary>
            <remarks>The initial pixel in the image equals zero</remarks>
            <returns> The image of the same size</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Rectangle{System.Double},`0,System.Int32)">
            <summary> Draw an Rectangle of the specific color and thickness </summary>
            <param name="rect"> The rectangle to be draw</param>
            <param name="color"> The color of the rectangle </param>
            <param name="thickness"> If thickness is less than 1, the rectangle is filled up </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.LineSegment2D{System.Int32},`0,System.Int32)">
            <summary> Draw a line segment of the specific color and thickness </summary>
            <param name="line"> The line segment to be draw</param>
            <param name="color"> The color of the line segment </param>
            <param name="thickness"> The thickness of the line segment </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw``1(Emgu.CV.Circle{``0},`0,System.Int32)">
            <summary> Draw a Circle of the specific color and thickness </summary>
            <param name="circle"> The circle to be draw</param>
            <param name="color"> The color of the circle </param>
            <param name="thickness"> If thickness is less than 1, the circle is filled up </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Ellipse{System.Single},`0,System.Int32)">
            <summary> Draw a Ellipse of the specific color and thickness </summary>
            <param name="ellipse"> The ellipse to be draw</param>
            <param name="color"> The color of the ellipse </param>
            <param name="thickness"> If thickness is less than 1, the ellipse is filled up </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(System.String,Emgu.CV.Font,Emgu.CV.Point2D{System.Int32},`0)">
            <summary>
            Draw the text using the specific font on the image
            </summary>
            <param name="message">The text message to be draw</param>
            <param name="font">The font used for drawing</param>
            <param name="bottomLeft">The location of the bottom left corner of the font</param>
            <param name="color">The color of the text</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Seq{Emgu.CV.MCvPoint},`0,`0,System.Int32)">
            <summary> Draw the contour with the specific color and thickness </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.DetectHaarCascade(Emgu.CV.HaarCascade)">
            <summary>
            Detect HaarCascade object in the current image, using predifined parameters
            </summary>
            <param name="haarObj">The object to be detected</param>
            <returns>The objects detected, one array per channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.DetectHaarCascade(Emgu.CV.HaarCascade,System.Double,System.Int32,System.Int32,Emgu.CV.MCvSize)">
            <summary>
            The function cvHaarDetectObjects finds rectangular regions in the given image that are likely to contain objects the cascade has been trained for and returns those regions as a sequence of rectangles. The function scans the image several times at different scales (see cvSetImagesForHaarClassifierCascade). Each time it considers overlapping regions in the image and applies the classifiers to the regions using cvRunHaarClassifierCascade. It may also apply some heuristics to reduce number of analyzed regions, such as Canny prunning. After it has proceeded and collected the candidate rectangles (regions that passed the classifier cascade), it groups them and returns a sequence of average rectangles for each large enough group. The default parameters (scale_factor=1.1, min_neighbors=3, flags=0) are tuned for accurate yet slow object detection. For a faster operation on real video images the settings are: scale_factor=1.2, min_neighbors=2, flags=CV_HAAR_DO_CANNY_PRUNING, min_size=&lt;minimum possible face size&gt; (for example, ~1/4 to 1/16 of the image area in case of video conferencing). 
            </summary>
            <param name="haarObj">Haar classifier cascade in internal representation</param>
            <param name="scaleFactor">The factor by which the search window is scaled between the subsequent scans, for example, 1.1 means increasing window by 10%</param>
            <param name="minNeighbors">Minimum number (minus 1) of neighbor rectangles that makes up an object. All the groups of a smaller number of rectangles than min_neighbors-1 are rejected. If min_neighbors is 0, the function does not any grouping at all and returns all the detected candidate rectangles, which may be useful if the user wants to apply a customized grouping procedure</param>
            <param name="flag">Mode of operation. Currently the only flag that may be specified is CV_HAAR_DO_CANNY_PRUNING. If it is set, the function uses Canny edge detector to reject some image regions that contain too few or too much edges and thus can not contain the searched object. The particular threshold values are tuned for face detection and in this case the pruning speeds up the processing.</param>
            <param name="minSize">Minimum window size. By default, it is set to the size of samples the classifier has been trained on (~20×20 for face detection)</param>
            <returns>The objects detected, one array per channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.HughLinesBinary(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary> 
            Apply Hugh transform to find line segments. 
            The current image must be a binary image (eg. the edges as a result of the Canny edge detector) 
            </summary> 
        </member>
        <member name="M:Emgu.CV.Image`2.HughLines(`0,`0,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary> 
            First apply Canny Edge Detector on the current image, 
            then apply Hugh transform to find line segments 
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.HughCircles(`0,`0,System.Double,System.Double,System.Int32,System.Int32)">
            <summary> 
            First apply Canny Edge Detector on the current image, 
            then apply Hugh transform to find circles 
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.RoiParam(System.IntPtr,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Return parameters based on ROI
            </summary>
            <param name="ptr">The Pointer to the IplImage</param>
            <param name="start">The address of thepointer that point to the start of the Bytes taken into consideration ROI</param>
            <param name="elementCount">ROI.Width * ColorType.Dimension</param>
            <param name="byteWidth">The number of bytes in a row taken into consideration ROI</param>
            <param name="rows">The number of rows taken into consideration ROI</param>
            <param name="widthStep">The width step required to jump to the next row</param>
        </member>
        <member name="M:Emgu.CV.Image`2.ForEachChannel``1(Emgu.Utils.Func{System.IntPtr,System.Int32,``0})">
            <summary>
            Apply convertor and compute result for each channel of the image, for single channel image, apply converter directly, for multiple channel image, make a copy of each channel to a temperary image and apply the convertor
            </summary>
            <typeparam name="R">The return type</typeparam>
            <param name="conv">The converter such that accept the IntPtr of a single channel IplImage, and image channel index which returning result of type R</param>
            <returns>An array which contains result for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ForEachDuplicateChannel``1(Emgu.Utils.Func{System.IntPtr,System.Int32,``0})">
            <summary>
            Apply convertor and compute result for each channel of the image, for single channel image, apply converter directly, for multiple channel image, make a copy of each channel to a temperary image and apply the convertor
            </summary>
            <typeparam name="R">The return type</typeparam>
            <param name="conv">The converter such that accept the IntPtr of a single channel IplImage, and image channel index which returning result of type R</param>
            <returns>An array which contains result for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ForEachChannel``1(Emgu.Utils.Action{System.IntPtr,System.IntPtr,System.Int32},Emgu.CV.Image{`0,``0})">
            <summary>
            If the image has only one channel, apply the action directly on the IntPtr of this image and <paramref name="image2"/>,
            otherwise, make copy each channel of this image to a temperary one, apply action on it and another temperory image and copy the resulting image back to image2
            </summary>
            <typeparam name="D2">The type of the depth of the <paramref name="dest"/> image</typeparam>
            <param name="act">The function which acepts the src IntPtr, dest IntPtr and index of the channel as input</param>
            <param name="dest">The destination image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Sobel(System.Int32,System.Int32,System.Int32)">
            <summary>
            The function cvSobel calculates the image derivative by convolving the image with the appropriate kernel:
            dst(x,y) = dxorder+yodersrc/dxxorder•dyyorder |(x,y)
            The Sobel operators combine Gaussian smoothing and differentiation so the result is more or less robust to the noise. Most often, the function is called with (xorder=1, yorder=0, aperture_size=3) or (xorder=0, yorder=1, aperture_size=3) to calculate first x- or y- image derivative.
            </summary>
            <param name="xorder">Order of the derivative x</param>
            <param name="yorder">Order of the derivative y</param>
            <param name="apertureSize">Size of the extended Sobel kernel, must be 1, 3, 5 or 7. In all cases except 1, aperture_size ×aperture_size separable kernel will be used to calculate the derivative.</param>
            <returns>The result of the sobel edge detector</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Laplace(System.Int32)">
             <summary>
             The function cvLaplace calculates Laplacian of the source image by summing second x- and y- derivatives calculated using Sobel operator:
             dst(x,y) = d2src/dx2 + d2src/dy2
             Specifying aperture_size=1 gives the fastest variant that is equal to convolving the image with the following kernel:
            
             |0  1  0|
             |1 -4  1|
             |0  1  0|
             </summary>
             <param name="apertureSize">Aperture size </param>
             <returns>The Laplacian of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Canny(`0,`0)">
            <summary> Find the edges on this image and marked them in the returned image.</summary>
            <param name="thresh"> The threshhold to find initial segments of strong edges</param>
            <param name="threshLinking"> The threshold used for edge Linking</param>
            <returns> The edges found by the Canny edge detector</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GoodFeaturesToTrack(System.Int32,System.Double,System.Double,System.Int32,System.Boolean,System.Double)">
            <summary>
            The function cvGoodFeaturesToTrack finds corners with big eigenvalues in the image. The function first calculates the minimal eigenvalue for every source image pixel using cvCornerMinEigenVal function and stores them in eig_image. Then it performs non-maxima suppression (only local maxima in 3x3 neighborhood remain). The next step is rejecting the corners with the minimal eigenvalue less than quality_level•max(eig_image(x,y)). Finally, the function ensures that all the corners found are distanced enough one from another by considering the corners (the most strongest corners are considered first) and checking that the distance between the newly considered feature and the features considered earlier is larger than min_distance. So, the function removes the features than are too close to the stronger features
            </summary>
            <param name="maxFeaturesPerChannel">The maximum features to be detected per channel</param>
            <param name="quality_level">Multiplier for the maxmin eigenvalue; specifies minimal accepted quality of image corners</param>
            <param name="min_distance">Limit, specifying minimum possible distance between returned corners; Euclidian distance is used. </param>
            <param name="block_size">Size of the averaging block, passed to underlying cvCornerMinEigenVal or cvCornerHarris used by the function</param>
            <param name="use_harris">If nonzero, Harris operator (cvCornerHarris) is used instead of default cvCornerMinEigenVal</param>
            <param name="k">Free parameter of Harris detector; used only if use_harris = true </param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.MatchTemplate(Emgu.CV.Image{`0,`1},Emgu.CV.CvEnum.TM_TYPE)">
            <summary>
            The function cvMatchTemplate is similiar to cvCalcBackProjectPatch. It slids through image, compares overlapped patches of size w×h with templ using the specified method and stores the comparison results to result
            </summary>
            <param name="template">Searched template; must be not greater than the source image and the same data type as the image</param>
            <param name="method">Specifies the way the template must be compared with image regions </param>
            <returns>The comparison result</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Snake(Emgu.CV.Seq{Emgu.CV.MCvPoint},System.Single,System.Single,System.Single,Emgu.CV.Point2D{System.Int32},Emgu.CV.MCvTermCriteria,Emgu.CV.MemStorage)">
             <summary>
             The function cvSnakeImage updates snake in order to minimize its total energy that is a sum of internal energy that depends on contour shape (the smoother contour is, the smaller internal energy is) and external energy that depends on the energy field and reaches minimum at the local energy extremums that correspond to the image edges in case of image gradient.
            The parameter criteria.epsilon is used to define the minimal number of points that must be moved during any iteration to keep the iteration process running. 
            If at some iteration the number of moved points is less than criteria.epsilon or the function performed criteria.max_iter iterations, the function terminates. 
             </summary>
             <param name="c">Some existing contour</param>
             <param name="alpha">Weight[s] of continuity energy, single float or array of length floats, one per each contour point</param>
             <param name="beta">Weight[s] of curvature energy, similar to alpha.</param>
             <param name="gamma">Weight[s] of image energy, similar to alpha.</param>
             <param name="windowSize">Size of neighborhood of every point used to search the minimum, both win.width and win.height must be odd</param>
             <param name="tc">Termination criteria</param>
             <param name="storage"> the memory storage used by the resulting sequence</param>
             <returns>The snake[d] contour</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise AND operation with another image and return the result</summary>
            <param name="img2">The second image for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Gray,System.Byte})">
            <summary> 
            Perform an elementwise AND operation with another image, using a mask, and return the result
            </summary>
            <param name="img2">The second image for the AND operation</param>
            <param name="mask">The mask for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(`0)">
            <summary> Perform an binary AND operation with some color</summary>
            <param name="val">The color for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(`0,Emgu.CV.Image{Emgu.CV.Gray,System.Byte})">
            <summary> Perform an binary AND operation with some color using a mask</summary>
            <param name="val">The color for the AND operation</param>
            <param name="mask">The mask for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise OR operation with another image and return the result</summary>
            <param name="img2">The second image for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Gray,System.Byte})">
            <summary> Perform an elementwise OR operation with another image, using a mask, and return the result</summary>
            <param name="img2">The second image for the OR operation</param>
            <param name="mask">The mask for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(`0)">
            <summary> Perform an elementwise OR operation with some color</summary>
            <param name="val">The value for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(`0,Emgu.CV.Image{Emgu.CV.Gray,System.Byte})">
            <summary> Perform an elementwise OR operation with some color using a mask</summary>
            <param name="val">The color for the OR operation</param>
            <param name="mask">The mask for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise XOR operation with another image and return the result</summary>
            <param name="img2">The second image for the XOR operation</param>
            <returns> The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Gray,System.Byte})">
            <summary>
            Perform an elementwise XOR operation with another image, using a mask, and return the result
            </summary>
            <param name="img2">The second image for the XOR operation</param>
            <param name="mask">The mask for the XOR operation</param>
            <returns>The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(`0)">
            <summary> 
            Perform an binary XOR operation with some color
            </summary>
            <param name="val">The value for the XOR operation</param>
            <returns> The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(`0,Emgu.CV.Image{Emgu.CV.Gray,System.Byte})">
            <summary>
            Perform an binary XOR operation with some color using a mask
            </summary>
            <param name="val">The color for the XOR operation</param>
            <param name="mask">The mask for the XOR operation</param>
            <returns> The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Not">
            <summary> 
            Compute the complement image
            </summary>
            <returns> The complement image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Max(Emgu.CV.Image{`0,`1})">
            <summary> Find the elementwise maximum value </summary>
            <param name="img2">The second image for the Max operation</param>
            <returns> An image where each pixel is the maximum of <i>this</i> image and the parameter image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Max(System.Double)">
            <summary> Find the elementwise maximum value </summary>
            <param name="value">The value to compare with</param>
            <returns> An image where each pixel is the maximum of <i>this</i> image and <paramref name="value"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Min(Emgu.CV.Image{`0,`1})">
            <summary> Find the elementwise minimum value </summary>
            <param name="img2">The second image for the Min operation</param>
            <returns> An image where each pixel is the minimum of <i>this</i> image and the parameter image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Min(System.Double)">
            <summary> Find the elementwise minimum value </summary>
            <param name="value">The value to compare with</param>
            <returns> An image where each pixel is the minimum of <i>this</i> image and <paramref name="value"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.InRange(`0,`0)">
            <summary>Checks that image elements lie between two scalars</summary>
            <param name="lower"> The lower limit of color value</param>
            <param name="higher"> The upper limit of color value</param>
            <returns> res[i,j] = 255 if inrange, 0 otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Cmp(Emgu.CV.Image{`0,`1},Emgu.CV.CvEnum.CMP_TYPE)">
            <summary>
            This function compare the current image with <paramref name="img2"/> and returns the comparison mask
            </summary>
            <param name="img2">The other image to compare with</param>
            <param name="cmp_type">The comparison type</param>
            <returns>The result of the comparison as a mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Cmp(System.Double,Emgu.CV.CvEnum.CMP_TYPE)">
            <summary>
            This function compare the current image with <paramref name="value"/> and returns the comparison mask
            </summary>
            <param name="value">The value to compare with</param>
            <param name="cmp_type">The comparison type</param>
            <returns>The result of the comparison as a mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.CountNonZero">
            <summary>
            Count the non Zero elements for each channel
            </summary>
            <returns>Count the non Zero elements for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Equals(Emgu.CV.Image{`0,`1})">
            <summary>
            Compare two images, returns true if the each of the pixels are equal, false otherwise
            </summary>
            <param name="img2">The other image to compare with</param>
            <returns>true if the each of the pixels for the two images are equal, false otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sub(Emgu.CV.Image{`0,`1})">
            <summary> Elementwise subtract another image from the current image </summary>
            <param name="img2">The second image to be subtraced from the current image</param>
            <returns> The result of elementwise subtracting img2 from the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sub(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Gray,System.Byte})">
            <summary> Elementwise subtrace another image from the current image, using a mask</summary>
            <param name="img2">The image to be subtraced from the current image</param>
            <param name="mask">The mask for the subtract operation</param>
            <returns> The result of elementwise subtrating img2 from the current image, using the specific mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sub(`0)">
            <summary> Elementwise subtrace a color from the current image</summary>
            <param name="val">The color value to be subtraced from the current image</param>
            <returns> The result of elementwise subtracting color 'val' from the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SubR(`0)">
            <summary>
            result = val - this
            </summary>
            <param name="val">the value which subtract this image</param>
            <returns>val - this</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SubR(`0,Emgu.CV.Image{Emgu.CV.Gray,System.Byte})">
            <summary>
            result = val - this, using a mask
            </summary>
            <param name="val">the value which subtract this image</param>
            <param name="mask"> The mask for substraction</param>
            <returns>val - this, with mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Add(Emgu.CV.Image{`0,`1})">
            <summary> Elementwise add another image with the current image </summary>
            <param name="img2">The image to be added to the current image</param>
            <returns> The result of elementwise adding img2 to the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Add(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Gray,System.Byte})">
            <summary> Elementwise add <paramref name="img2"/> with the current image, using a mask</summary>
            <param name="img2">The image to be added to the current image</param>
            <param name="mask">The mask for the add operation</param>
            <returns> The result of elementwise adding img2 to the current image, using the specific mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Add(`0)">
            <summary> Elementwise add a color <paramref name="val"/> to the current image</summary>
            <param name="val">The color value to be added to the current image</param>
            <returns> The result of elementwise adding color <paramref name="val"/> from the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Mul(Emgu.CV.Image{`0,`1},System.Double)">
            <summary> Elementwise multiply another image with the current image and the <paramref name="scale"/></summary>
            <param name="img2">The image to be elementwise multiplied to the current image</param>
            <param name="scale">The scale to be multiplied</param>
            <returns> this .* img2 * scale </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Mul(Emgu.CV.Image{`0,`1})">
            <summary> Elementwise multiply <paramref name="img2"/> with the current image</summary>
            <param name="img2">The image to be elementwise multiplied to the current image</param>
            <returns> this .* img2 </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Mul(System.Double)">
            <summary> Elementwise multiply the current image with <paramref name="scale"/></summary>
            <param name="scale">The scale to be multiplied</param>
            <returns> The scaled image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.AddWeighted(Emgu.CV.Image{`0,`1},System.Double,System.Double,System.Double)">
            <summary> Return the weighted sum such that: res = this * alpha + img2 * beta + gamma</summary>
        </member>
        <member name="M:Emgu.CV.Image`2.RunningAvg(Emgu.CV.Image{`0,`1},System.Double)">
            <summary> Update Running Average. <i>this</i> = (1-alpha)*<i>this</i> + alpha*img) </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.Pow(System.Double)">
            <summary>
            Raises every element of input array to p
            dst(I)=src(I)^p, if p is integer
            dst(I)=abs(src(I))^p, otherwise
            </summary>
            <param name="power">The exponent of power</param>
            <returns>The power image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Exp">
            <summary>
            calculates exponent of every element of input array:
            dst(I)=exp(src(I))
            Maximum relative error is ≈7e-6. Currently, the function converts denormalized values to zeros on output.
            </summary>
            <returns>The exponent image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.DFT(Emgu.CV.CvEnum.CV_DXT,System.Int32)">
            <summary>
            performs forward or inverse transform of 1D or 2D floating-point array
            </summary>
            <param name="type">Transformation flags</param>
            <param name="nonzeroRows">Number of nonzero rows to in the source array (in case of forward 2d transform), or a number of rows of interest in the destination array (in case of inverse 2d transform). If the value is negative, zero, or greater than the total number of rows, it is ignored. The parameter can be used to speed up 2d convolution/correlation when computing them via DFT</param>
            <returns>The result of DFT</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.DFT(Emgu.CV.CvEnum.CV_DXT)">
            <summary>
            performs forward or inverse transform of 2D floating-point image
            </summary>
            <param name="type">Transformation flags</param>
            <returns>The result of DFT</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.DCT(Emgu.CV.CvEnum.CV_DCT_TYPE)">
            <summary>
            performs forward or inverse transform of 2D floating-point image
            </summary>
            <param name="type">Transformation flags</param>
            <returns>The result of DCT</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Log">
            <summary>
            Calculates natural logarithm of absolute value of every element of input array
            </summary>
            <returns>Natural logarithm of absolute value of every element of input array</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.AbsDiff(Emgu.CV.Image{`0,`1})">
            <summary> 
            Computes absolute different between <i>this</i> image and the other image
            </summary>
            <param name="img2">The other image to compute absolute different with</param>
            <returns> The image that contains the absolute different value</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sample(Emgu.CV.LineSegment2D{System.Int32})">
            <summary> Sample the pixel values on the specific line segment </summary>
            <param name="line"> The line to obtain samples</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Int32,System.Int32)">
            <summary>
             Scale the image to the specific size 
             </summary>
            <param name="width">The width of the returned image.</param>
            <param name="height">The height of the returned image.</param>
            <returns>The resized image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Scale the image to the specific size
            </summary>
            <param name="width">The width of the returned image.</param>
            <param name="height">The height of the returned image.</param>
            <param name="preserverScale">if true, the scale is preservered and the resulting image has maximum width(height) possible that is &lt;= <paramref name="width"/> (<paramref name="height"/>), if false, this function is equaivalent to Resize(int width, int height)</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Double)">
            <summary>
             Scale the image to the specific size: width *= scale; height *= scale  
             </summary>
             <returns>The scaled image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Rotate(System.Double,`0)">
            <summary>
            Rotate the image the specified angle cropping the result to the original size
            </summary>
            <param name="angle">The angle of rotation in degrees.</param>
            <param name="background">The color with wich to fill the background</param>        
        </member>
        <member name="M:Emgu.CV.Image`2.Rotate(System.Double,`0,System.Boolean)">
            <summary>
            Rotate the image the specified angle
            </summary>
            <param name="angle">The angle of rotation in degrees.</param>
            <param name="background">The color with wich to fill the background</param>
            <param name="crop">If set to true the image is cropped to its original size, possibly losing corners information. If set to false the result image has different size than original and all rotation information is preserved</param>
            <returns>The rotated image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``2">
            <summary> Convert the current image to the specific color and depth </summary>
            <typeparam name="C2"> The type of color to be converted to </typeparam>
            <typeparam name="D2"> The type of pixel depth to be converted to </typeparam>
            <returns> Image of the specific color and depth </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ConvertScale``1(System.Double,System.Double)">
            <summary> Convert the current image to the specific depth, at the same time scale and shift the values of the pixel</summary>
            <param name="scale"> The value to be multipled with the pixel </param>
            <param name="shift"> The value to be added to the pixel</param>
            <returns> Image of the specific depth, val = val * scale + shift </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ToBitmap">
            <summary> 
            Convert this image into Bitmap, the pixel values are copied over to the Bitmap
            </summary>
            <remarks> For better performance on Image&lt;Gray, Byte&gt; and Image&lt;Bgr, Byte&gt;, consider using the Bitmap property </remarks>
            <returns> This image in Bitmap format, the pixel data are copied over to the Bitmap</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ToBitmap(System.Int32,System.Int32)">
            <summary> Create a Bitmap image of certain size</summary>
            <param name="width">The width of the bitmap</param>
            <param name="height"> The height of the bitmap</param>
            <returns> This image in Bitmap format of the specific size</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.PyrDown">
            <summary>
            The function PyrDown performs downsampling step of Gaussian pyramid decomposition. 
            First it convolves <i>this</i> image with the specified filter and then downsamples the image 
            by rejecting even rows and columns.
            </summary>
            <returns> The downsampled image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.PyrUp">
            <summary>
            The function cvPyrUp performs up-sampling step of Gaussian pyramid decomposition. 
            First it upsamples <i>this</i> image by injecting even zero rows and columns and then convolves 
            result with the specified filter multiplied by 4 for interpolation. 
            So the resulting image is four times larger than the source image.
            </summary>
            <returns> The upsampled image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.InPaint(Emgu.CV.Image{Emgu.CV.Gray,System.Byte},System.Double)">
            <summary> Use impaint to recover the intensity of the pixels which location defined by <paramref>mask</paramref> on <i>this</i> image </summary>
            <returns> The inpainted image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Erode(System.Int32)">
            <summary>
            Erodes <i>this</i> image using a 3x3 rectangular structuring element.
            Erosion are applied serveral (iterations) times
            </summary>
            <returns> The eroded image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Dilate(System.Int32)">
            <summary>
            Dilates <i>this</i> image using a 3x3 rectangular structuring element.
            Dilation are applied serveral (iterations) times
            </summary>
            <returns> The dialated image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._Erode(System.Int32)">
            <summary>
            Erodes <i>this</i> image inplace using a 3x3 rectangular structuring element.
            Erosion are applied serveral (iterations) times
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2._Dilate(System.Int32)">
            <summary>
            Dilates <i>this</i> image inplace using a 3x3 rectangular structuring element.
            Dilation are applied serveral (iterations) times
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.Action(System.Action{`1})">
            <summary> perform an generic action based on each element of the Image</summary>
        </member>
        <member name="M:Emgu.CV.Image`2.Action``1(Emgu.CV.Image{`0,``0},Emgu.Utils.Action{`1,``0})">
            <summary>
            perform an generic operation based on the elements of the two images
            </summary>
            <typeparam name="D2">The depth of the second image</typeparam>
            <param name="img2">The second image to perform action on</param>
            <param name="action">An action such that the first parameter is the a single channel of a pixel from the first image, the second parameter is the corresponding channel of the correspondind pixel from the second image </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``1(Emgu.Utils.Func{`1,System.Int32,System.Int32,``0})">
            <summary> Compute the element of a new image based on the value as well as the x and y positions of each pixel on the image</summary> 
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``1(System.Converter{`1,``0})">
            <summary> Compute the element of the new image based on element of this image</summary> 
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``2(Emgu.CV.Image{`0,``0},Emgu.Utils.Func{`1,``0,``1})">
            <summary> Compute the element of the new image based on the elements of the two image</summary>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``3(Emgu.CV.Image{`0,``0},Emgu.CV.Image{`0,``1},Emgu.Utils.Func{`1,``0,``1,``2})">
            <summary> Compute the element of the new image based on the elements of the three image</summary>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``4(Emgu.CV.Image{`0,``0},Emgu.CV.Image{`0,``1},Emgu.CV.Image{`0,``2},Emgu.Utils.Func{`1,``0,``1,``2,``3})">
            <summary> Compute the element of the new image based on the elements of the four image</summary>
        </member>
        <member name="M:Emgu.CV.Image`2.FreeUnmanagedObjects">
            <summary>
            Release all unmanaged memory associate with the image
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>
            Perform an elementwise AND operation on the two images
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="img2">The second image to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
            Perform an elementwise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
            Perform an elementwise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(Emgu.CV.Image{`0,`1},`0)">
            <summary>
            Perform an elementwise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(`0,Emgu.CV.Image{`0,`1})">
            <summary>
            Perform an elementwise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise OR operation with another image and return the result</summary>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(Emgu.CV.Image{`0,`1},System.Double)">
            <summary> 
             Perform an binary OR operation with some color
             </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(System.Double,Emgu.CV.Image{`0,`1})">
            <summary> 
             Perform an binary OR operation with some color
             </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(Emgu.CV.Image{`0,`1},`0)">
            <summary> 
             Perform an binary OR operation with some color
             </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(`0,Emgu.CV.Image{`0,`1})">
            <summary> 
             Perform an binary OR operation with some color
             </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_OnesComplement(Emgu.CV.Image{`0,`1})">
            <summary> Compute the complement image</summary>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise add <paramref name="img1"/> with <paramref name="img2"/>
            </summary>
            <param name="img1">The first image to be added</param>
            <param name="img2">The second image to be added</param>
            <returns>The sum of the two images</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise add <paramref name="img1"/> with <paramref name="val"/>
            </summary>
            <param name="img1">The image to be added</param>
            <param name="val">The value to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
            Elementwise add <paramref name="img1"/> with <paramref name="val"/>
            </summary>
            <param name="img1">The image to be added</param>
            <param name="val">The value to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(Emgu.CV.Image{`0,`1},`0)">
            <summary>
            Elementwise add <paramref name="img1"/> with <paramref name="val"/>
            </summary>
            <param name="img1">The image to be added</param>
            <param name="val">The color to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(`0,Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise add <paramref name="img1"/> with <paramref name="val"/>
            </summary>
            <param name="img1">The image to be added</param>
            <param name="val">The color to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise subtract another image from the current image
            </summary>
            <param name="img1">The image to be substracted</param>
            <param name="img2">The second image to be subtraced from <paramref name="img1"/></param>
            <returns> The result of elementwise subtracting img2 from <paramref name="img1"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(Emgu.CV.Image{`0,`1},`0)">
            <summary>
            Elementwise subtract another image from the current image
            </summary>
            <param name="img1">The image to be substracted</param>
            <param name="val">The color to be subtracted</param>
            <returns> The result of elementwise subtracting <paramred name="val"/> from <paramref name="img1"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(`0,Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise subtract another image from the current image
            </summary>
            <param name="img1">The image to be substracted</param>
            <param name="val">The color to be subtracted</param>
            <returns> <paramred name="val"/> - <paramref name="img1"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
            <paramred name="val"/> - <paramref name="img1"/>
            </summary>
            <param name="img1">The image to be substracted</param>
            <param name="val">The value to be subtracted</param>
            <returns> <paramred name="val"/> - <paramref name="img1"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
            Elementwise subtract another image from the current image
            </summary>
            <param name="img1">The image to be substracted</param>
            <param name="val">The value to be subtracted</param>
            <returns> <paramref name="img1"/> - <paramred name="val"/>   </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Multiply(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
             <paramref name="img1"/> * <paramref name="scale"/>
            </summary>
            <param name="img1">The image</param>
            <param name="scale">The multiplication scale</param>
            <returns><paramref name="img1"/> * <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Multiply(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
              <paramref name="scale"/>*<paramref name="img1"/>
            </summary>
            <param name="img1">The image</param>
            <param name="scale">The multiplication scale</param>
            <returns><paramref name="scale"/>*<paramref name="img1"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Multiply(Emgu.CV.Image{`0,`1},Emgu.CV.ConvolutionKernelF)">
            <summary>
            Perform the convolution with <paramref name="kernel"/> on <paramref name="img1"/>
            </summary>
            <param name="img1">The image</param>
            <param name="kernel">The kernel</param>
            <returns>Result of the convolution</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Division(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
             <paramref name="img1"/> / <paramref name="scale"/>
            </summary>
            <param name="img1">The image</param>
            <param name="scale">The division scale</param>
            <returns><paramref name="img1"/> / <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Division(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
              <paramref name="scale"/> / <paramref name="img1"/>
            </summary>
            <param name="img1">The image</param>
            <param name="scale">The scale</param>
            <returns><paramref name="scale"/> / <paramref name="img1"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Convolution(Emgu.CV.ConvolutionKernelF)">
            <summary> performs a convolution using the provided kernel </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.GaussianSmooth(System.Int32)">
            <summary> Perform Gaussian Smoothing in the current image and return the result </summary>
            <param name="kernelSize"> The size of the Gaussian kernel (<paramref>kernelSize</paramref> x <paramref>kernelSize</paramref>)</param>
            <returns> The smoothed image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GaussianSmooth(System.Int32,System.Int32,System.Double)">
            <summary> Perform Gaussian Smoothing in the current image and return the result </summary>
            <param name="kernelWidth"> The width of the Gaussian kernel</param>
            <param name="kernelHeight"> The height of the Gaussian kernel</param>
            <param name="sigma"> The standard deviation of the Gaussian kernel</param>
            <returns> The smoothed image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._GaussianSmooth(System.Int32)">
            <summary> Perform Gaussian Smoothing inplace for the current image </summary>
            <param name="kernelSize"> The size of the Gaussian kernel (<paramref>kernelSize</paramref> x <paramref>kernelSize</paramref>)</param>
        </member>
        <member name="M:Emgu.CV.Image`2._GaussianSmooth(System.Int32,System.Int32,System.Double)">
            <summary> Perform Gaussian Smoothing inplace for the current image </summary>
            <param name="kernelWidth"> The width of the Gaussian kernel</param>
            <param name="kernelHeight"> The height of the Gaussian kernel</param>
            <param name="sigma"> The standard deviation of the Gaussian kernel</param>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdBase(Emgu.CV.Image{`0,`1},`0,`0,Emgu.CV.CvEnum.THRESH)">
            <summary> 
            the base threshold method shared by public threshold functions 
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdToZero(`0)">
            <summary> Threshold the image such that: dst(x,y) = src(x,y), if src(x,y)>threshold;  0, otherwise </summary>
            <returns> dst(x,y) = src(x,y), if src(x,y)>threshold;  0, otherwise </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdToZeroInv(`0)">
            <summary> Threshold the image such that: dst(x,y) = 0, if src(x,y)>threshold;  src(x,y), otherwise </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdTrunc(`0)">
            <summary> Threshold the image such that: dst(x,y) = threshold, if src(x,y)>threshold; src(x,y), otherwise </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdBinary(`0,`0)">
            <summary> Threshold the image such that: dst(x,y) = max_value, if src(x,y)>threshold; 0, otherwise </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdBinaryInv(`0,`0)">
            <summary> Threshold the image such that: dst(x,y) = 0, if src(x,y)>threshold;  max_value, otherwise </summary>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdToZero(`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = src(x,y), if src(x,y)>threshold;  0, otherwise </summary>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdToZeroInv(`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = 0, if src(x,y)>threshold;  src(x,y), otherwise </summary>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdTrunc(`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = threshold, if src(x,y)>threshold; src(x,y), otherwise </summary>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdBinary(`0,`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = max_value, if src(x,y)>threshold; 0, otherwise </summary>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdBinaryInv(`0,`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = 0, if src(x,y)>threshold;  max_value, otherwise </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.Flip(Emgu.CV.CvEnum.FLIP)">
            <summary> Return a filpped copy of the current image</summary>
            <param name="flipType">The type of the flipping</param>
            <returns> The flipped copy of <i>this</i> image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.FindContours(Emgu.CV.CvEnum.CHAIN_APPROX_METHOD,Emgu.CV.CvEnum.RETR_TYPE,Emgu.CV.MemStorage)">
            <summary>
            Find a sequence of contours
            </summary>
            <param name="method">The type of approximation method</param>
            <param name="type">The retrival type</param>
            <param name="stor">The storage used by the sequences</param>
            <returns>A sequence of CvContours</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Moment(System.Boolean)">
            <summary>
            Calculates spatial and central moments up to the third order and writes them to moments. The moments may be used then to calculate gravity center of the shape, its area, main axises and various shape characeteristics including 7 Hu invariants.
            </summary>
            <param name="binary">If the flag is true, all the zero pixel values are treated as zeroes, all the others are treated as 1’s</param>
            <returns>spatial and central moments up to the third order</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Split">
            <summary> 
            Split current Image into an array of gray scale images where each element 
            in the array represent a single color channel of the original image
            </summary>
            <returns> 
            An array of gray scale images where each element 
            in the array represent a single color channel of the original image 
            </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.MinMax">
            <summary>
            Returns the min / max location and values for the image
            For Image&lt;Bgr, Byte&gt; img and minmax = img.MinMax();
            minmax[0] contains the minmax locations and values for B channel and minmax[1] contains the minmax location for G channel etc.
            minmax[0][0] contains the min locations and values for B channel and minmax[0][1] contains the max locations and values for B channel.
            minmax[0][0].X and minmax[0][0].Y contains the X and Y coordinates for the min location and minmix[0][0].Z contains the minimum value for B channel
            </summary>
            <returns>
            Returns the min / max location and values for the image
            For Image&lt;Bgr, Byte&gt; img and minmax = img.MinMax();
            minmax[0] contains the minmax locations and values for B channel and minmax[1] contains the minmax location for G channel etc.
            minmax[0][0] contains the min locations and values for B channel and minmax[0][1] contains the max locations and values for B channel.
            minmax[0][0].X and minmax[0][0].Y contains the X and Y coordinates for the min location and minmix[0][0].Z contains the minimum value for B channel
            </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Save(System.String)">
            <summary>
            Save this image to the specific file
            </summary>
            <param name="fileName">The name of the file to be saved to</param>
        </member>
        <member name="P:Emgu.CV.Image`2.Data">
            <summary>
            Get or Set the data for this matrix
            </summary>
            <remarks> 
            The Get function has O(1) complexity. 
            If the image contains Byte and width is not a multiple of 4. The second dimension of the array might be larger than the Width of this image.  
            This is necessary since the length of a row need to be 4 align for OpenCV optimization. 
            The Set function always make a copy of the specific value. If the image contains Byte and width is not a multiple of 4. The second dimension of the array created might be larger than the Width of this image.  
            </remarks>
        </member>
        <member name="P:Emgu.CV.Image`2.MIplImage">
            <summary>
            The IplImage structure
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.ROI">
            <summary> 
             The region of interest for this image 
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.Width">
            <summary> 
            The width of the image ( number of pixels in the x direction),
            if ROI is set, the width of the ROI 
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.Height">
            <summary> 
            The height of the image ( number of pixels in the y direction ),
            if ROI is set, the height of the ROI 
            </summary> 
        </member>
        <member name="P:Emgu.CV.Image`2.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.Size">
            <summary> 
             The size of the internal iplImage structure, regardness of the ROI of this image: X -- Width; Y -- Height.
             When a new size is assigned to this property, the original image is resized (the ROI is resized as well when 
             available)
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.CvDepth">
            <summary>
            The depth value in opencv for this image
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.isROISet">
            <summary> 
            Indicates if the region of interest has been set
            </summary> 
        </member>
        <member name="P:Emgu.CV.Image`2.Average">
            <summary> The average color of this image </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.Sum">
            <summary> The sum for each color channel </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.Binary">
            <summary>
            To be removed in the next version, use Data property instead
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.Item(System.Int32,System.Int32)">
            <summary>
            Get or Set the color in the <paramref name="row"/>th row (y direction) and <paramref name="column"/>th column (x direction)
            </summary>
            <param name="row">the row (y direction) of the pixel </param>
            <param name="column">the column (x direction) of the pixel</param>
            <returns>the color in the <paramref name="row"/>th row and <paramref name="column"/>th column</returns>
        </member>
        <member name="P:Emgu.CV.Image`2.Item(Emgu.CV.Point2D{System.Int32})">
            <summary>
            Get or Set the color in the <paramref name="location"/>
            </summary>
            <param name="location">the location of the pixel </param>
            <returns>the color in the <paramref name="location"/></returns>
        </member>
        <member name="P:Emgu.CV.Image`2.Bitmap">
            <summary>
            The Get property provide a more efficient way to convert Image&lt;Gray, Byte&gt; and Image&lt;Bgr, Byte&gt; into Bitmap
            such that the image data is <b>shared</b> with Bitmap. 
            If you change the pixel value on the Bitmap, you change the pixel values on the Image object as well!
            For other types of image this property has the same effect as ToBitmap()
            <b>Take extra caution not to use the Bitmap after the Image object is disposed</b>
            The Set property convert the bitmap to this Image type.
            </summary>
        </member>
        <member name="M:Emgu.CV.TimedImage`2.#ctor">
            <summary>
            Create a blank Image of size one by one
            </summary>
        </member>
        <member name="M:Emgu.CV.TimedImage`2.#ctor(System.Int32,System.Int32,`0)">
            <summary>
            Create a blank Image of the specified width, height, depth and color.
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="value">The initial color of the image</param>
        </member>
        <member name="M:Emgu.CV.TimedImage`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a blank Image of the specified width, height, depth. 
            <b>Warning</b>: The color is not initialized and could be random value 
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
        </member>
        <member name="P:Emgu.CV.TimedImage`2.Timestamp">
            <summary> 
            The time this image is captured
            </summary>
        </member>
        <member name="T:Emgu.CV.Point3D`1">
            <summary> A 3D point </summary>
            <typeparam name="T"> The type of value for this 3D point</typeparam>
        </member>
        <member name="M:Emgu.CV.Point3D`1.#ctor">
            <summary> Create a 3D point located in the origin</summary>
        </member>
        <member name="M:Emgu.CV.Point3D`1.#ctor(`0,`0,`0)">
            <summary> Create a 3D point of the specific location</summary>
            <param name="x"> The x value of this point</param>
            <param name="y"> The y value of this point</param>
            <param name="z"> The z value of this point</param>
        </member>
        <member name="P:Emgu.CV.Point3D`1.Z">
            <summary> The z value of this point</summary>
        </member>
        <member name="T:Emgu.CV.MCvSeq">
            <summary>
            Managed structure equivalent to CvSeq
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSeq.flags">
            <summary>
             micsellaneous flags 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSeq.header_size">
            <summary>
             size of sequence header 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSeq.h_prev">
            <summary>
             previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSeq.h_next">
            <summary>
             next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSeq.v_prev">
            <summary>
             2nd previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSeq.v_next">
            <summary>
             2nd next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSeq.total">
            <summary>
             total number of elements 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSeq.elem_size">
            <summary>
            size of sequence element in bytes 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSeq.block_max">
            <summary>
            maximal bound of the last block 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSeq.ptr">
            <summary>
             current write pointer 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSeq.delta_elems">
            <summary>
             how many elements allocated when the sequence grows (sequence granularity 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSeq.storage">
            <summary>
             where the seq is stored 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSeq.free_blocks">
            <summary>
             free blocks list 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSeq.first">
            <summary>
             pointer to the first sequence block 
            </summary>
        </member>
        <member name="T:Emgu.CV.MCvPoint">
            <summary>
            Managed Structure equivalent to CvPoint
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvPoint.x">
            <summary>
            x-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvPoint.y">
            <summary>
            y-coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.MCvPoint.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a MCvPoint structure with the specific x and y coordinates
            </summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
        </member>
        <member name="T:Emgu.CV.MCvMoments">
            <summary>
            spatial and central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.m00">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.m10">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.m01">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.m20">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.m11">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.m02">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.m30">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.m21">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.m12">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.m03">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.mu20">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.mu11">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.mu02">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.mu30">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.mu21">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.mu12">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.mu03">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMoments.inv_sqrt_m00">
            <summary>
            m00 != 0 ? 1/sqrt(m00) : 0
            </summary>
        </member>
        <member name="T:Emgu.CV.Gray">
            <summary> Defines a Gray color </summary>
        </member>
        <member name="M:Emgu.CV.Gray.#ctor(System.Double)">
            <summary> Create a Gray color with the given intensity</summary>
            <param name="intensity"> The intensity for this color </param>
        </member>
        <member name="M:Emgu.CV.Gray.#ctor">
            <summary> Create a Gray color with o intensity </summary>
        </member>
        <member name="M:Emgu.CV.Gray.CompareTo(System.Object)">
            <summary>
            Compare method that implement IComparable interface
            </summary>
            <param name="obj">The other object to compare to</param>
            <returns>a positive value if greater, 0 if equal, negative value if smaller</returns>
        </member>
        <member name="P:Emgu.CV.Gray.Intensity">
            <summary> The intensity of the gray color </summary>
            <value> The intensity of the gray color</value>
        </member>
        <member name="T:Emgu.CV.CameraCalibration.IntrinsicCameraParameters">
            <summary>
            The intrinsic camera parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.IntrinsicCameraParameters.#ctor">
            <summary>
            Create the intrinsic camera parameters
            </summary>
        </member>
        <member name="P:Emgu.CV.CameraCalibration.IntrinsicCameraParameters.DistortionCoeffs">
            <summary>
            Get or Set the DistortionCoeffs ( as a 3x1 matrix )
            </summary>
        </member>
        <member name="P:Emgu.CV.CameraCalibration.IntrinsicCameraParameters.IntrinsicMatrix">
            <summary>
            Get or Set the intrinsic matrix
            </summary>
        </member>
        <member name="T:Emgu.CV.Utils">
            <summary>
            Utilities class
            </summary>
        </member>
        <member name="F:Emgu.CV.Utils.GrayscalePalette">
            <summary>
            The ColorPalette of Grayscale for Bitmap Format8bppIndexed
            </summary>
        </member>
        <member name="M:Emgu.CV.Utils.OptimizeCV(System.Boolean)">
            <summary>
            Enable or diable IPL optimization of opencv
            </summary>
            <param name="flag">true to enable optimization, false to disable</param>
        </member>
        <member name="T:Emgu.CV.UI.PropertyDlg">
            <summary>
            A dialog to display the property of an image
            </summary>
        </member>
        <member name="F:Emgu.CV.UI.PropertyDlg.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Emgu.CV.UI.PropertyDlg.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Emgu.CV.UI.PropertyDlg.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:Emgu.CV.UI.PropertyDlg.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Emgu.CV.UI.PropertyDlg.ImagePropertyPanel">
            <summary>
            Get the image property panel
            </summary>
        </member>
        <member name="T:Emgu.CV.Line2D`1">
            <summary> A 2D line </summary>
        </member>
        <member name="F:Emgu.CV.Line2D`1._p1">
            <summary> A point on the line </summary>
        </member>
        <member name="F:Emgu.CV.Line2D`1._p2">
            <value> An other point on the line </value>
        </member>
        <member name="M:Emgu.CV.Line2D`1.#ctor">
            <summary>
            Create a default line
            </summary>
        </member>
        <member name="M:Emgu.CV.Line2D`1.#ctor(Emgu.CV.Point2D{`0},Emgu.CV.Point2D{`0})">
            <summary> 
            Create a line by specifing two points on the line
            </summary>
            <param name="p1"> A point on the line </param>
            <param name="p2"> An other point on the line </param>
        </member>
        <member name="M:Emgu.CV.Line2D`1.YByX(`0)">
            <summary> Obtain the Y value from the X value</summary>
            <param name="x">The X value</param>
            <returns>The Y value</returns>
        </member>
        <member name="P:Emgu.CV.Line2D`1.P1">
            <summary> A point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Line2D`1.P2">
            <summary> An other point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Line2D`1.Direction">
            <summary> The direction of the line, the norm of which is 1 </summary>
        </member>
        <member name="T:Emgu.CV.MCvPoint3D32f">
            <summary>
            Managed Structure equivalent to CvPoint2D32f
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvPoint3D32f.x">
            <summary>
            x-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvPoint3D32f.y">
            <summary>
            y-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvPoint3D32f.z">
            <summary>
            z-coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.MCvPoint3D32f.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Create a MCvPoint2D32f structure with the specific x and y coordinates
            </summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
            <param name="z">z-coordinate</param>
        </member>
        <member name="T:Emgu.CV.MCvHuMoments">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvHuMoments.hu1">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvHuMoments.hu2">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvHuMoments.hu3">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvHuMoments.hu4">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvHuMoments.hu5">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvHuMoments.hu6">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvHuMoments.hu7">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="T:Emgu.CV.MCvContour">
            <summary>
            Managed structure equivalent to CvContour
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvContour.flags">
            <summary>
             micsellaneous flags 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvContour.header_size">
            <summary>
             size of sequence header 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvContour.h_prev">
            <summary>
             previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvContour.h_next">
            <summary>
             next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvContour.v_prev">
            <summary>
             2nd previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvContour.v_next">
            <summary>
             2nd next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvContour.total">
            <summary>
             total number of elements 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvContour.elem_size">
            <summary>
             size of sequence element in bytes 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvContour.block_max">
            <summary>
             maximal bound of the last block 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvContour.ptr">
            <summary>
             current write pointer 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvContour.delta_elems">
            <summary>
             how many elements allocated when the seq grows 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvContour.storage">
            <summary>
             where the seq is stored 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvContour.free_blocks">
            <summary>
             free blocks list 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvContour.first">
            <summary>
             pointer to the first sequence block 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvContour.rect">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvContour.color">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvContour.reserved">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.MCvConnectedComp">
            <summary>
            Managed structure equivalent to CvConnectedComp
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvConnectedComp.area">
            <summary>
            area of the segmented component
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvConnectedComp.value">
            <summary>
            gray scale value of the segmented component
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvConnectedComp.rect">
            <summary>
            ROI of the segmented component
            </summary>
        </member>
        <member name="T:Emgu.CV.Font">
            <summary>
            A wraper to CvFont
            </summary>
        </member>
        <member name="M:Emgu.CV.Font.#ctor(Emgu.CV.CvEnum.FONT,System.Double,System.Double)">
            <summary>
            Create a Font of the specific type, horizontal scale and vertical scale
            </summary>
            <param name="type">The type of the font</param>
            <param name="hscale">The horizontal scale of the font</param>
            <param name="vscale">the vertical scale of the fonr</param>
        </member>
        <member name="M:Emgu.CV.Font.FreeUnmanagedObjects">
            <summary>
            Release the font object
            </summary>
        </member>
        <member name="T:Emgu.CV.ConvolutionKernelF">
            <summary>
            The kernel that can be use as the parameter of the Convulution function in Image class
            </summary>
        </member>
        <member name="F:Emgu.CV.ConvolutionKernelF._center">
            <summary>
            The center of the convolution kernel
            </summary>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a convolution kernel of the specific rows and cols
            </summary>
            <param name="rows">The number of raws for the convolution kernel</param>
            <param name="cols">The number of columns for the convolution kernel</param>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.#ctor(Emgu.CV.Matrix{System.Single},Emgu.CV.Point2D{System.Int32})">
            <summary>
            Create a convolution kernel using the specific matrix and center
            </summary>
            <param name="kernel">the values for the convolution kernel</param>
            <param name="center">the center of the kernel</param>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.#ctor(System.Single[0:,0:])">
            <summary>
            Create a convolution kernel using the specific floating point matrix
            </summary>
            <param name="kernel">the values for the convolution kernel</param>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.#ctor(System.Single[0:,0:],Emgu.CV.Point2D{System.Int32})">
            <summary>
            Create a convolution kernel using the specific floating point matrix and center
            </summary>
            <param name="kernel">the values for the convolution kernel</param>
            <param name="center">the center for the convolution kernel</param>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.Flip(Emgu.CV.CvEnum.FLIP)">
            <summary> Return a filpped copy of the convolution kernel</summary>
            <param name="flipType">The type of the flipping</param>
            <returns> The flipped copy of <i>this</i> image </returns>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.Transpose">
            <summary>
            Obtain the transpose of the convolution kernel
            </summary>
            <returns></returns>
        </member>
        <member name="P:Emgu.CV.ConvolutionKernelF.Center">
            <summary>
            The center of the convolution kernel
            </summary>
        </member>
        <member name="T:Emgu.CV.MCvSlice">
            <summary>
            Managed structure equivalent to CvSlice
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSlice.start_index">
            <summary>
            Start index
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSlice.end_index">
            <summary>
            End index
            </summary>
        </member>
        <member name="M:Emgu.CV.MCvSlice.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new MCvSlice using the specific start and end index
            </summary>
            <param name="start">start index</param>
            <param name="end">end index</param>
        </member>
        <member name="T:Emgu.CV.MCvScalar">
            <summary>
            Managed structure equivalent to CvScalar 
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvScalar.v0">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvScalar.v1">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvScalar.v2">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvScalar.v3">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="M:Emgu.CV.MCvScalar.#ctor(System.Double[])">
            <summary>
            Create a new MCvScalar structure using the specific values
            </summary>
            <param name="values"></param>
        </member>
        <member name="P:Emgu.CV.MCvScalar.v">
            <summary>
            The scalar values as a vector (of size 4)
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CMP_TYPE">
            <summary>
            Type used for cvCmp Function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CMP_TYPE.CV_CMP_EQ">
            <summary>
            src1(I) "equal to" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CMP_TYPE.CV_CMP_GT">
            <summary>
            src1(I) "greater than" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CMP_TYPE.CV_CMP_GE">
            <summary>
            src1(I) "greater or equal" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CMP_TYPE.CV_CMP_LT">
            <summary>
            src1(I) "less than" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CMP_TYPE.CV_CMP_LE">
            <summary>
            src1(I) "less or equal" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CMP_TYPE.CV_CMP_NE">
            <summary>
            src1(I) "not equal to" src2(I)
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.APPROX_POLY_TYPE">
            <summary>
            Polygon approximation type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.APPROX_POLY_TYPE.CV_POLY_APPROX_DP">
            <summary>
            Douglas-Peucker algorithm
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CAP_PROP">
            <summary>
            CV Capture property identifier
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_POS_MSEC">
            <summary>
            film current position in milliseconds or video capture timestamp
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_POS_FRAMES">
            <summary>
            0-based index of the frame to be decoded/captured next
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_POS_AVI_RATIO">
            <summary>
            position in relative units (0 - start of the file, 1 - end of the file)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_FRAME_WIDTH">
            <summary>
            width of frames in the video stream
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_FRAME_HEIGHT">
            <summary>
            height of frames in the video stream
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_FPS">
            <summary>
            frame rate 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_FOURCC">
            <summary>
            4-character code of codec
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_FRAME_COUNT">
            <summary>
            number of frames in video file
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_FORMAT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_MODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_BRIGHTNESS">
            <summary>
            Brightness
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_CONTRAST">
            <summary>
            Contrast
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_SATURATION">
            <summary>
            Saturation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_HUE">
            <summary>
            Hue
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_GAIN">
            <summary>
            Gain
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_CONVERT_RGB">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CHAIN_APPROX_METHOD">
            <summary>
            contour approximation method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHAIN_APPROX_METHOD.CV_CHAIN_CODE">
            <summary>
            output contours in the Freeman chain code. All other methods output polygons (sequences of vertices). 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHAIN_APPROX_METHOD.CV_CHAIN_APPROX_NONE">
            <summary>
            translate all the points from the chain code into points;
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHAIN_APPROX_METHOD.CV_CHAIN_APPROX_SIMPLE">
            <summary>
            compress horizontal, vertical, and diagonal segments, that is, the function leaves only their ending points; 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHAIN_APPROX_METHOD.CV_CHAIN_APPROX_TC89_L1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHAIN_APPROX_METHOD.CV_CHAIN_APPROX_TC89_KCOS">
            <summary>
            apply one of the flavors of Teh-Chin chain approximation algorithm
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHAIN_APPROX_METHOD.CV_LINK_RUNS">
            <summary>
            use completely different contour retrieval algorithm via linking of horizontal segments of 1’s. Only CV_RETR_LIST retrieval mode can be used with this method
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.COLOR_CONVERSION">
            <summary>
            Color Conversion code
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2BGRA">
            <summary>
            Convert BGR color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGRA2BGR">
            <summary>
            Convert BGRA color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2GRAY">
            <summary>
            Convert BGR color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_GRAY2BGR">
            <summary>
            Convert GRAY color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_GRAY2BGRA">
            <summary>
            Convert GRAY color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGRA2GRAY">
            <summary>
            Convert BGRA color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2BGR565">
            <summary>
            Convert BGR color to BGR565 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR5652BGR">
            <summary>
            Convert BGR565 color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGRA2BGR565">
            <summary>
            Convert BGRA color to BGR565 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR5652BGRA">
            <summary>
            Convert BGR565 color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_GRAY2BGR565">
            <summary>
            Convert GRAY color to BGR565 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR5652GRAY">
            <summary>
            Convert BGR565 color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2BGR555">
            <summary>
            Convert BGR color to BGR555 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR5552BGR">
            <summary>
            Convert BGR555 color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGRA2BGR555">
            <summary>
            Convert BGRA color to BGR555 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR5552BGRA">
            <summary>
            Convert BGR555 color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_GRAY2BGR555">
            <summary>
            Convert GRAY color to BGR555 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR5552GRAY">
            <summary>
            Convert BGR555 color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2XYZ">
            <summary>
            Convert BGR color to XYZ color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_XYZ2BGR">
            <summary>
            Convert XYZ color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2YCrCb">
            <summary>
            Convert BGR color to YCrCb color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_YCrCb2BGR">
            <summary>
            Convert YCrCb color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2HSV">
            <summary>
            Convert BGR color to HSV color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2Lab">
            <summary>
            Convert BGR color to Lab color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BayerBG2BGR">
            <summary>
            Convert BayerBG color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BayerGB2BGR">
            <summary>
            Convert BayerGB color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BayerRG2BGR">
            <summary>
            Convert BayerRG color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BayerGR2BGR">
            <summary>
            Convert BayerGR color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2Luv">
            <summary>
            Convert BGR color to Luv color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2HLS">
            <summary>
            Convert BGR color to HLS color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_HSV2BGR">
            <summary>
            Convert HSV color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_Lab2BGR">
            <summary>
            Convert Lab color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_Luv2BGR">
            <summary>
            Convert Luv color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_HLS2BGR">
            <summary>
            Convert HLS color to BGR color
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.FILTER_TYPE">
            <summary>
            Type for cvPyrUp(cvPryDown)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FILTER_TYPE.CV_GAUSSIAN_5x5">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.FONT">
            <summary>
            Fonts
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FONT.CV_FONT_HERSHEY_SIMPLEX">
            <summary>
            HERSHEY_SIMPLEX
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FONT.CV_FONT_HERSHEY_PLAIN">
            <summary>
            HERSHEY_PLAIN
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FONT.CV_FONT_HERSHEY_DUPLEX">
            <summary>
            HERSHEY_DUPLEX
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FONT.CV_FONT_HERSHEY_COMPLEX">
            <summary>
            HERSHEY_COMPLEX
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FONT.CV_FONT_HERSHEY_TRIPLEX">
            <summary>
            HERSHEY_TRIPLEX
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FONT.CV_FONT_HERSHEY_COMPLEX_SMALL">
            <summary>
            HERSHEY_COMPLEX_SMALL
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FONT.CV_FONT_HERSHEY_SCRIPT_SIMPLEX">
            <summary>
            HERSHEY_SCRIPT_SIMPLEX
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FONT.CV_FONT_HERSHEY_SCRIPT_COMPLEX">
            <summary>
            HERSHEY_SCRIPT_COMPLEX
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.GEMM_TYPE">
            <summary>
            Flags used for cvGEMM function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GEMM_TYPE.CV_GEMM_A_T">
            <summary>
            transpose src1
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GEMM_TYPE.CV_GEMM_B_T">
            <summary>
            transpose src2
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GEMM_TYPE.CV_GEMM_C_T">
            <summary>
            transpose src3
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.HOUGH_TYPE">
            <summary>
            Hough detection type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HOUGH_TYPE.CV_HOUGH_STANDARD">
            <summary>
            classical or standard Hough transform. Every line is represented by two floating-point numbers (ρ, θ), where ρ is a distance between (0,0) point and the line, and θ is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HOUGH_TYPE.CV_HOUGH_PROBABILISTIC">
            <summary>
            probabilistic Hough transform (more efficient in case if picture contains a few long linear segments). It returns line segments rather than the whole lines. Every segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of CV_32SC4 type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HOUGH_TYPE.CV_HOUGH_MULTI_SCALE">
            <summary>
            multi-scale variant of classical Hough transform. The lines are encoded the same way as in CV_HOUGH_STANDARD
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HOUGH_TYPE.CV_HOUGH_GRADIENT">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.INPAINT_TYPE">
            <summary>
            Inpaint type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.INPAINT_TYPE.CV_INPAINT_NS">
            <summary>
            Navier-Stokes based method.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.INPAINT_TYPE.CV_INPAINT_TELEA">
            <summary>
            The method by Alexandru Telea 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.INTER">
            <summary>
            Types for CvResize
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.INTER.CV_INTER_NN">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.INTER.CV_INTER_LINEAR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.INTER.CV_INTER_AREA">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SMOOTH_TYPE">
            <summary>
            Interpolation type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SMOOTH_TYPE.CV_BLUR_NO_SCALE">
            <summary>
            (simple blur with no scaling) - summation over a pixel param1×param2 neighborhood. If the neighborhood size may vary, one may precompute integral image with cvIntegral function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SMOOTH_TYPE.CV_BLUR">
            <summary>
            (simple blur) - summation over a pixel param1×param2 neighborhood with subsequent scaling by 1/(param1•param2). 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SMOOTH_TYPE.CV_GAUSSIAN">
            <summary>
            (gaussian blur) - convolving image with param1×param2 Gaussian kernel. 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SMOOTH_TYPE.CV_MEDIAN">
            <summary>
            (median blur) - finding median of param1×param1 neighborhood (i.e. the neighborhood is square). 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SMOOTH_TYPE.CV_BILATERAL">
            <summary>
            (bilateral filter) - applying bilateral 3x3 filtering with color sigma=param1 and space sigma=param2. Information about bilateral filtering can be found 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.LOAD_IMAGE_TYPE">
            <summary>
            cvLoadImage type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LOAD_IMAGE_TYPE.CV_LOAD_IMAGE_UNCHANGED">
            <summary>
            8bit, color or not 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LOAD_IMAGE_TYPE.CV_LOAD_IMAGE_GRAYSCALE">
            <summary>
            8bit, gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LOAD_IMAGE_TYPE.CV_LOAD_IMAGE_COLOR">
            <summary>
            ?, color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LOAD_IMAGE_TYPE.CV_LOAD_IMAGE_ANYDEPTH">
            <summary>
            any depth, ?
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LOAD_IMAGE_TYPE.CV_LOAD_IMAGE_ANYCOLOR">
            <summary>
            ?, any color
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.MAT_DEPTH">
            <summary>
            Type of matrix depth
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MAT_DEPTH.CV_8U">
            <summary>
            8bit unsigned
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MAT_DEPTH.CV_8S">
            <summary>
            8bit signed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MAT_DEPTH.CV_16U">
            <summary>
            16bit unsigned
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MAT_DEPTH.CV_16S">
            <summary>
            16bit signed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MAT_DEPTH.CV_32S">
            <summary>
            32bit signed 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MAT_DEPTH.CV_32F">
            <summary>
            32bit float
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MAT_DEPTH.CV_64F">
            <summary>
            64bit
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.RAND_TYPE">
            <summary>
            CV_RAND TYPE
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RAND_TYPE.CV_RAND_UNI">
            <summary>
            Uniform distribution
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RAND_TYPE.CV_RAND_NORMAL">
            <summary>
            Normal distribution
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.RETR_TYPE">
            <summary>
            contour retrieval mode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RETR_TYPE.CV_RETR_EXTERNAL">
            <summary>
            retrive only the extreme outer contours 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RETR_TYPE.CV_RETR_LIST">
            <summary>
             retrieve all the contours and puts them in the list 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RETR_TYPE.CV_RETR_CCOMP">
            <summary>
            retrieve all the contours and organizes them into two-level hierarchy: top level are external boundaries of the components, second level are bounda boundaries of the holes 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RETR_TYPE.CV_RETR_TREE">
            <summary>
            retrieve all the contours and reconstructs the full hierarchy of nested contours 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SEQ_ELTYPE">
            <summary>
            CV_SEQ_ELTYPE
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_POINT">
            <summary>
              (x,y) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_CODE">
            <summary>  
            freeman code: 0..7 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_GENERIC">
            <summary>  
            unspecified type of sequence elements 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_PTR">
            <summary>  
            =6 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_PPOINT">
            <summary>  
            pointer to element of other sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_INDEX">
            <summary>  
            index of element of some other sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_GRAPH_EDGE">
            <summary>  
            next_o, next_d, vtx_o, vtx_d 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_GRAPH_VERTEX">
            <summary>  
            first_edge, (x,y) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_TRIAN_ATR">
            <summary>  
            vertex of the binary tree   
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_CONNECTED_COMP">
            <summary>  
            connected component  
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_POINT3D">
            <summary>  
            (x,y,z)  
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SEQ_TYPE">
            <summary>
            Sequence type for point sets
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_TYPE.CV_SEQ_POINT_SET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_TYPE.CV_SEQ_POINT3D_SET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_TYPE.CV_SEQ_POLYLINE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_TYPE.CV_SEQ_POLYGON">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_TYPE.CV_SEQ_SIMPLE_POLYGON">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.TERMCRIT">
            <summary>
            CV_TERMCRIT
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TERMCRIT.CV_TERMCRIT_ITER">
            <summary>
            Iteration
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TERMCRIT.CV_TERMCRIT_EPS">
            <summary>
            Epsilon
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.THRESH">
            <summary>
            Types of thresholding 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.THRESH.CV_THRESH_BINARY">
            <summary>
            value = value > threshold ? max_value : 0
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.THRESH.CV_THRESH_BINARY_INV">
            <summary>
             value = value > threshold ? 0 : max_value       
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.THRESH.CV_THRESH_TRUNC">
            <summary>
             value = value > threshold ? threshold : value   
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.THRESH.CV_THRESH_TOZERO">
            <summary>
             value = value > threshold ? value : 0           
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.THRESH.CV_THRESH_TOZERO_INV">
            <summary>
             value = value > threshold ? 0 : value           
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.THRESH.CV_THRESH_MASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.THRESH.CV_THRESH_OTSU">
            <summary>
             use Otsu algorithm to choose the optimal threshold value;
             combine the flag with one of the above CV_THRESH_* values 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.TM_TYPE">
            <summary>
            Methods for comparing two array
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TM_TYPE.CV_TM_SQDIFF">
            <summary>
            R(x,y)=sumx',y'[T(x',y')-I(x+x',y+y')]2
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TM_TYPE.CV_TM_SQDIFF_NORMED">
            <summary>
            R(x,y)=sumx',y'[T(x',y')-I(x+x',y+y')]2/sqrt[sumx',y'T(x',y')2•sumx',y'I(x+x',y+y')2]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TM_TYPE.CV_TM_CCORR">
            <summary>
            R(x,y)=sumx',y'[T(x',y')•I(x+x',y+y')]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TM_TYPE.CV_TM_CCORR_NORMED">
            <summary>
            R(x,y)=sumx',y'[T(x',y')•I(x+x',y+y')]/sqrt[sumx',y'T(x',y')2•sumx',y'I(x+x',y+y')2]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TM_TYPE.CV_TM_CCOEFF">
            <summary>
            R(x,y)=sumx',y'[T'(x',y')•I'(x+x',y+y')],
            where T'(x',y')=T(x',y') - 1/(w•h)•sumx",y"T(x",y")
               I'(x+x',y+y')=I(x+x',y+y') - 1/(w•h)•sumx",y"I(x+x",y+y")
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TM_TYPE.CV_TM_CCOEFF_NORMED">
            <summary>
            R(x,y)=sumx',y'[T'(x',y')•I'(x+x',y+y')]/sqrt[sumx',y'T'(x',y')2•sumx',y'I'(x+x',y+y')2]
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.IPL_DEPTH">
            <summary>
            IPL_DEPTH
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_SIGN">
            <summary>
            indicates if the value is signed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_1U">
            <summary>
            1bit unsigned
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_8U">
            <summary>
            8bit unsigned (Byte)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_16U">
            <summary>
            16bit unsigned
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_32F">
            <summary>
            32bit float (Single)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_8S">
            <summary>
            8bit signed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_16S">
            <summary>
            16bit signed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_32S">
            <summary>
            32bit signed 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F">
            <summary>
            double
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.FLIP">
            <summary>
            Enumeration used by cvFlip
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FLIP.HORIZONTAL">
            <summary>
            Flip horizontally
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FLIP.VERTICAL">
            <summary>
            Flip vertically
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CHECK_TYPE">
            <summary>
            Enumeration used by cvCheckArr
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHECK_TYPE.CHECK_NAN_INFINITY">
            <summary>
            checks that every element is neigther NaN nor ±Infinity
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHECK_TYPE.CHECK_RANGE">
            <summary>
            if set, the function checks that every value of array is within [minVal,maxVal) range, otherwise it just checks that every element is neigther NaN nor ±Infinity
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHECK_TYPE.CHECK_QUIET">
            <summary>
            if set, the function does not raises an error if an element is invalid or out of range
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.LINE_TYPE">
            <summary>
            The type of line for drawing
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LINE_TYPE.EIGHT_CONNECTED">
            <summary>
            8-connected
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LINE_TYPE.FOUR_CONNECTED">
            <summary>
            4-connected
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LINE_TYPE.CV_AA">
            <summary>
            Antialias
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.DIST_TYPE">
            <summary>
            Defines for Distance Transform
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DIST_TYPE.CV_DIST_USER">
            <summary>
              User defined distance 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DIST_TYPE.CV_DIST_L1">
            <summary>
              distance = |x1-x2| + |y1-y2| 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DIST_TYPE.CV_DIST_L2">
            <summary>
              the simple euclidean distance 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DIST_TYPE.CV_DIST_C">
            <summary>
              distance = max(|x1-x2|,|y1-y2|) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DIST_TYPE.CV_DIST_L12">
            <summary>
              L1-L2 metric: distance = 2(sqrt(1+x*x/2) - 1)) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DIST_TYPE.CV_DIST_FAIR">
            <summary>
              distance = c^2(|x|/c-log(1+|x|/c)), c = 1.3998 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DIST_TYPE.CV_DIST_WELSCH">
            <summary>
              distance = c^2/2(1-exp(-(x/c)^2)), c = 2.9846 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DIST_TYPE.CV_DIST_HUBER">
            <summary>
              distance = |x|&lt;c ? x^2/2 : c(|x|-c/2), c=1.345 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CV_DXT">
            <summary>
            Flag used for cvDFT
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_DXT.CV_DXT_FORWARD">
            <summary>
             do forward 1D or 2D transform. The result is not scaled
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_DXT.CV_DXT_INVERSE">
            <summary>
            do inverse 1D or 2D transform. The result is not scaled. CV_DXT_FORWARD and CV_DXT_INVERSE are mutually exclusive, of course
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_DXT.CV_DXT_SCALE">
            <summary>
            scale the result: divide it by the number of array elements. Usually, it is combined with CV_DXT_INVERSE, and one may use a shortcut 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_DXT.CV_DXT_ROWS">
            <summary>
            do forward or inverse transform of every individual row of the input matrix. This flag allows user to transform multiple vectors simultaneously and can be used to decrease the overhead (which is sometimes several times larger than the processing itself), to do 3D and higher-dimensional transforms etc
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_DXT.CV_DXT_INV_SCALE">
            <summary>
            Inverse and scale
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CV_DCT_TYPE">
            <summary>
            Flag used for cvDCT
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_DCT_TYPE.CV_DXT_FORWARD">
            <summary>
             do forward 1D or 2D transform. The result is not scaled
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_DCT_TYPE.CV_DXT_INVERSE">
            <summary>
            do inverse 1D or 2D transform. The result is not scaled. CV_DXT_FORWARD and CV_DXT_INVERSE are mutually exclusive, of course
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_DCT_TYPE.CV_DXT_ROWS">
            <summary>
            do forward or inverse transform of every individual row of the input matrix. This flag allows user to transform multiple vectors simultaneously and can be used to decrease the overhead (which is sometimes several times larger than the processing itself), to do 3D and higher-dimensional transforms etc
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CV_FM">
            <summary>
            Calculates fundamental matrix given a set of corresponding points
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_FM.CV_FM_7POINT">
            <summary>
            for 7-point algorithm. N == 7
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_FM.CV_FM_8POINT">
            <summary>
            for 8-point algorithm. N >= 8
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_FM.CV_FM_LMEDS_ONLY">
            <summary>
            for LMedS algorithm. N >= 8
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_FM.CV_FM_RANSAC_ONLY">
            <summary>
            for RANSAC algorithm. N >= 8
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_FM.CV_FM_LMEDS">
            <summary>
            CV_FM_LMEDS_ONLY | CV_FM_8POINT
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_FM.CV_FM_RANSAC">
            <summary>
            CV_FM_RANSAC_ONLY | CV_FM_8POINT
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.GENERAL">
            <summary>
            General enumeration
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GENERAL.CV_MAX_DIM">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ERROR_CODES">
            <summary>
             Error codes
             </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSOK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSBACKTRACE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSERROR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSINTERNAL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSNOMEM">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSBADARG">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSBADFUNC">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSNOCONV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSAUTOTRACE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_HEADERISNULL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADIMAGESIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADOFFSET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADDATAPTR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADSTEP">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADMODELORCHSEQ">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADNUMCHANNELS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADNUMCHANNEL1U">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADDEPTH">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADALPHACHANNEL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADORDER">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADORIGIN">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADALIGN">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADCALLBACK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADTILESIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADCOI">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADROISIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_MASKISTILED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSNULLPTR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSVECLENGTHERR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSFILTERSTRUCTCONTENTERR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSKERNELSTRUCTCONTENTERR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSFILTEROFFSETERR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSBADSIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSDIVBYZERO">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSINPLACENOTSUPPORTED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSOBJECTNOTFOUND">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSUNMATCHEDFORMATS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSBADFLAG">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSBADPOINT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSBADMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSUNMATCHEDSIZES">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSUNSUPPORTEDFORMAT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSOUTOFRANGE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSPARSEERROR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSNOTIMPLEMENTED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSBADMEMBLOCK">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.WARP">
            <summary>
            Types for CvWarpAffine
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS">
            <summary>
            fill all the destination image pixels. If some of them correspond to outliers in the source image, they are set to fillval.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.WARP.CV_WARP_INVERSE_MAP">
            <summary>
            indicates that matrix is inverse transform from destination image to source and, thus, can be used directly for pixel interpolation. Otherwise, the function finds the inverse transform from map_matrix.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ADAPTIVE_THRESHOLD_TYPE">
            <summary>
            Types of Adaptive Threshold
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ADAPTIVE_THRESHOLD_TYPE.CV_ADAPTIVE_THRESH_MEAN_C">
            <summary>
            indicates that "Mean minus C" should be used for adaptive threshold.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ADAPTIVE_THRESHOLD_TYPE.CV_ADAPTIVE_THRESH_GAUSSIAN_C">
            <summary>
            indicates that "Gaussian minus C" should be used for adaptive threshold.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CV_ELEMENT_SHAPE">
            <summary>
            Shape of the Structuring Element
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_ELEMENT_SHAPE.CV_SHAPE_RECT">
            <summary>
            A rectangular element.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_ELEMENT_SHAPE.CV_SHAPE_CROSS">
            <summary>
            A cross-shaped element.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_ELEMENT_SHAPE.CV_SHAPE_ELLIPSE">
            <summary>
            An elliptic element.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_ELEMENT_SHAPE.CV_SHAPE_CUSTOM">
            <summary>
            A user-defined element.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CV_MORPH_OP">
            <summary>
            Type of Morphological Operation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_MORPH_OP.CV_MOP_OPEN">
            <summary>
            Opening.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_MORPH_OP.CV_MOP_CLOSE">
            <summary>
            Closing.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_MORPH_OP.CV_MOP_GRADIENT">
            <summary>
            Morphological Gradient.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_MORPH_OP.CV_MOP_TOPHAT">
            <summary>
            "Top Hat".
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_MORPH_OP.CV_MOP_BLACKHAT">
            <summary>
            "Black Hat".
            </summary>
        </member>
        <member name="T:Emgu.CV.MCvSize2D32f">
            <summary>
            Managed structure equivalent to CvSize2D32f
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSize2D32f.width">
            <summary>
            The width of the size
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSize2D32f.height">
            <summary>
            The height of the size
            </summary>
        </member>
        <member name="M:Emgu.CV.MCvSize2D32f.#ctor(System.Single,System.Single)">
            <summary>
            Create a new MCvSize2D32f using the specific width and height
            </summary>
            <param name="w">width</param>
            <param name="h">height</param>
        </member>
        <member name="T:Emgu.CV.RotationMatrix2D">
            <summary>
            A 2D rotation matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.#ctor">
            <summary>
            Create an empty (2x3) 2D rotation matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.#ctor(Emgu.CV.Point2D{System.Single},System.Double,System.Double)">
            <summary>
            Create a 2D rotation matrix
            </summary>
            <param name="center">Center of the rotation in the source image</param>
            <param name="angle">The rotation angle in degrees. Positive values mean couter-clockwise rotation (the coordiate origin is assumed at top-left corner). </param>
            <param name="scale">Isotropic scale factor.</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D.SetRotation(Emgu.CV.Point2D{System.Single},System.Double,System.Double)">
            <summary>
            Set the values of the rotation matrix
            </summary>
            <param name="center">Center of the rotation in the source image</param>
            <param name="angle">The rotation angle in degrees. Positive values mean couter-clockwise rotation (the coordiate origin is assumed at top-left corner). </param>
            <param name="scale">Isotropic scale factor.</param>
        </member>
        <member name="T:Emgu.CV.CvException">
            <summary>
            The default exception to be thrown when error encounter in Open CV 
            </summary>
        </member>
        <member name="M:Emgu.CV.CvException.#ctor(System.Int32,System.String,System.String,System.String,System.Int32)">
            <summary>
            The default exception to be thrown when error is encountered in Open CV 
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the souce where error is encountered</param>
        </member>
        <member name="P:Emgu.CV.CvException.Status">
            <summary>
            The numeric code for error status
            </summary>
        </member>
        <member name="P:Emgu.CV.CvException.ErrorStr">
            <summary>
            The corresponding error string for the Status code
            </summary>
        </member>
        <member name="P:Emgu.CV.CvException.FunctionName">
            <summary>
            The name of the function the error is encountered
            </summary>
        </member>
        <member name="P:Emgu.CV.CvException.ErrorMessage">
            <summary>
            A description of the error
            </summary>
        </member>
        <member name="P:Emgu.CV.CvException.FileName">
            <summary>
            The source file name where error is encountered
            </summary>
        </member>
        <member name="P:Emgu.CV.CvException.Line">
            <summary>
            The line number in the souce where error is encountered
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoWriter">
            <summary>
            Create a video writer that write images to video format
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoWriter.#ctor(System.String,System.Int32,Emgu.CV.Point2D{System.Int32},System.Boolean)">
            <summary>
            Create a video writer using the specific information
            </summary>
            <param name="filename">The name of the video file to be written to </param>
            <param name="fps">frame rate per second</param>
            <param name="frameSize">the size of the frame</param>
            <param name="isColor">true if this is a color video, false otherwise</param>
        </member>
        <member name="M:Emgu.CV.VideoWriter.WriteFrame``2(Emgu.CV.Image{``0,``1})">
            <summary>
            Write a single frame to the video writer
            </summary>
            <typeparam name="C">The color type of the frame</typeparam>
            <typeparam name="D">The depth of the frame</typeparam>
            <param name="frame">The frame to be written to the video writer</param>
        </member>
        <member name="M:Emgu.CV.VideoWriter.FreeUnmanagedObjects">
            <summary>
            Release the video writer and all the memory associate with it
            </summary>
        </member>
        <member name="T:Emgu.CV.UI.ParamInputDlg">
            <summary>
            The dialog to ask user for parameters to the specific method
            </summary>
        </member>
        <member name="F:Emgu.CV.UI.ParamInputDlg.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Emgu.CV.UI.ParamInputDlg.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Emgu.CV.UI.ParamInputDlg.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:Emgu.CV.UI.ParamInputDlg.CreatePanelForParameter(System.Reflection.ParameterInfo)">
            <summary>
            Create a panel for the specific parameter
            </summary>
            <param name="param">the parameter to create panel for</param>
            <returns>the panel</returns>
        </member>
        <member name="M:Emgu.CV.UI.ParamInputDlg.GetParams(System.Reflection.MethodInfo,System.Collections.Generic.List{System.Object})">
            <summary>
            Obtain the parameters for <paramref name="method"/> and put them in <paramref name="paramList"/>
            </summary>
            <param name="method">The method to Obtain parameters from</param>
            <param name="paramList">The list that will be used as the storage for the retrieved parameters</param>
            <returns>True if successed, false otherwise</returns>
        </member>
        <member name="M:Emgu.CV.UI.ParamInputDlg.ParamInputPanel.GetValue">
            <summary>
            Return the value of the parameter input panel, if unable to retrieve value, return null
            </summary>
            <returns>The value of the parameter input panel, if unable to retrieve value, return null</returns>
        </member>
        <member name="P:Emgu.CV.UI.ParamInputDlg.ParamInputPanel.GetParamFunction">
            <summary>
            The function used to obtain the parameter from this input panel
            </summary>
        </member>
        <member name="T:Emgu.CV.PointCollection`1">
            <summary>
            A collection of points
            </summary>
        </member>
        <member name="F:Emgu.CV.PointCollection`1._xValueOfPointComparator">
            <summary>
            A comparator for used in the indexor
            </summary>
        </member>
        <member name="M:Emgu.CV.PointCollection`1.FirstDegreeInterpolate(Emgu.CV.Point2D{`0}[],`0)">
            <summary>
            Perform a first degree interpolation to lookup the y coordinate given the x coordinate
            </summary>
            <param name="points">The collection of points</param>
            <param name="index">the x coordinate</param>
            <returns>the y coordinate as the result of the first degree interpolation</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection`1.FirstDegreeInterpolate(Emgu.CV.Point2D{`0}[],`0[])">
            <summary>
            Perform a first degree interpolation to lookup the y coordinates given the x coordinates
            </summary>
            <param name="points">The collection of points</param>
            <param name="indexes">the x coordinates</param>
            <returns>the y coordinates as the result of the first degree interpolation</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection`1.To2D32fSequence(Emgu.CV.MemStorage,System.Collections.Generic.IEnumerable{Emgu.CV.Point{`0}})">
            <summary>
            Convert the points to a sequence of CvPoint2D32f
            </summary>
            <param name="stor">The sotrage</param>
            <param name="points">The points to be converted to sequence</param>
            <returns>A pointer to the sequence</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection`1.To3D32Sequence(Emgu.CV.MemStorage,System.Collections.Generic.IEnumerable{Emgu.CV.Point{`0}})">
            <summary>
            Convert the points to a sequence of CvPoint3D32f
            </summary>
            <param name="stor">The sotrage</param>
            <param name="points">The points to be converted to sequence</param>
            <returns>A pointer to the sequence</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection`1.ToMatrix(System.Collections.Generic.IEnumerable{Emgu.CV.Point{`0}})">
            <summary>
            Convert a collection of N Points to an (N x k) matrix, k is determined by the dimension of the first point
            </summary>
            <param name="points">The points which will be converted to matrix</param>
            <returns>the matrix representing the collection of points</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection`1.Line2DFitting(System.Collections.Generic.IEnumerable{Emgu.CV.Point{`0}},Emgu.CV.CvEnum.DIST_TYPE)">
            <summary>
            Fit a line to the points collection
            </summary>
            <param name="points">The points to be fitted</param>
            <param name="type">The type of the fitting</param>
            <returns>A 2D line</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection`1.LeastSquareEllipseFitting(System.Collections.Generic.IEnumerable{Emgu.CV.Point{`0}})">
            <summary>
            Fit an ellipse to the points collection
            </summary>
            <param name="points">The points to be fitted</param>
            <returns>An ellipse</returns>
        </member>
        <member name="T:Emgu.CV.PointCollection`1.XValueOfPointComparator">
            <summary>
            A comparator which compares only the X value of the point
            </summary>
        </member>
        <member name="T:Emgu.CV.Seq`1">
            <summary>
            The contour of an object
            </summary>
        </member>
        <member name="F:Emgu.CV.Seq`1._stor">
            <summary>
            The pointer to the storage used by this sequence
            </summary>
        </member>
        <member name="M:Emgu.CV.Seq`1.#ctor(Emgu.CV.MemStorage)">
            <summary>
            Create an empty contour
            </summary>
            <param name="storage"> The memory to be used for this contour</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.#ctor(System.Int32,Emgu.CV.MemStorage)">
            <summary>
            Create a sequence using the specific <paramref name="seq_flag"/> and <paramref name="storage"/>
            </summary>
            <param name="seq_flag">the sequence flag</param>
            <param name="storage">the storage</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.#ctor(System.IntPtr,Emgu.CV.MemStorage)">
            <summary>
            Create a sequence from the unmanaged pointer and the storage used by the pointer
            </summary>
            <param name="seq">The unmanaged sequence</param>
            <param name="storage">The memory storage this sequence utilize</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.ToArray">
            <summary>
            Convert this sequence to array
            </summary>
            <returns>the array representation of this sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.GetEnumerator">
            <summary>
            return an enumerator of the elements in the sequence
            </summary>
            <returns>an enumerator of the elements in the sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            return an enumerator of the elements in the sequence
            </summary>
            <returns>an enumerator of the elements in the sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.Slice(Emgu.CV.MCvSlice,Emgu.CV.MemStorage,System.Boolean)">
            <summary>
            Creates a sequence that represents the specified slice of the input sequence. The new sequence either shares the elements with the original sequence or has own copy of the elements. So if one needs to process a part of sequence but the processing function does not have a slice parameter, the required sub-sequence may be extracted using this function
            </summary>
            <param name="slice">The part of the sequence to extract</param>
            <param name="storage">The destination storage to keep the new sequence header and the copied data if any. If it is NULL, the function uses the storage containing the input sequence.</param>
            <param name="copy_data">The flag that indicates whether to copy the elements of the extracted slice </param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.FreeUnmanagedObjects">
            <summary>
            Release the contour and all the memory associate with it
            </summary>
        </member>
        <member name="M:Emgu.CV.Seq`1.ApproxPoly(System.Double,Emgu.CV.MemStorage)">
            <summary>
            The function cvApproxPoly approximates one or more curves and returns the approximation result[s]. In case of multiple curves approximation the resultant tree will have the same structure as the input one (1:1 correspondence)
            </summary>
            <param name="accuracy">The desired approximation accuracy</param>
            <param name="storage"> The storage the resulting sequence use</param>
            <returns>The approximated contour</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.Clear">
            <summary>
            The function cvClearSeq removes all elements from the sequence. The function does not return the memory to the storage, but this memory is reused later when new elements are added to the sequence. This function time complexity is O(1). 
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.Storage">
            <summary>
            A Pointer to the storage used by this Seq
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.MCvSeq">
            <summary>
            Get the MCvSeq structure
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.Item(System.Int32)">
            <summary>
            Obtain the <paramref name="index"/> element in this sequence
            </summary>
            <param name="index">the index of the element</param>
            <returns>the <paramref name="index"/> element in this sequence</returns>
        </member>
        <member name="P:Emgu.CV.Seq`1.HNext">
            <summary>
            Same as h_next pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.HPrev">
            <summary>
            Same as h_prev pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.VNext">
            <summary>
            Same as v_next pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.VPrev">
            <summary>
            Same as v_prev pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.Total">
            <summary> The number of vertices in the contour</summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.Area">
            <summary> 
             Get the area of the contour 
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.Convex">
            <summary> 
             Indicate if the coutour is a convex one 
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.Perimeter">
            <summary> 
             The perimeter of the sequence 
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.BoundingRectangle">
            <summary> The smallest Bouding Rectangle </summary>
        </member>
        <member name="T:Emgu.CV.Capture">
            <summary> Create a image capture base on opencv's capture object </summary>
        </member>
        <member name="T:Emgu.CV.IDuplexCapture">
            <summary>
            The interface to request a duplex image capture
            </summary>
        </member>
        <member name="M:Emgu.CV.IDuplexCapture.DuplexQueryFrame">
            <summary>
            Request a frame from server
            </summary>
        </member>
        <member name="M:Emgu.CV.IDuplexCapture.DuplexQuerySmallFrame">
            <summary>
            Request a frame from server which is half width and half height
            </summary>
        </member>
        <member name="F:Emgu.CV.Capture._width">
            <summary>
            the width of this capture
            </summary>
        </member>
        <member name="F:Emgu.CV.Capture._height">
            <summary>
            the height of this capture
            </summary>
        </member>
        <member name="M:Emgu.CV.Capture.#ctor">
            <summary> Create a capture using the default camera </summary>
        </member>
        <member name="M:Emgu.CV.Capture.#ctor(System.Int32)">
            <summary> Create a capture using the specific camera</summary>
            <param name="camIndex"> The index of the camera to create capture from, starting from 0</param>
        </member>
        <member name="M:Emgu.CV.Capture.#ctor(System.String)">
            <summary>
            Create a capture from file
            </summary>
            <param name="filename">The file name of the movie</param>
        </member>
        <member name="M:Emgu.CV.Capture.FreeUnmanagedObjects">
            <summary>
            Release the resource for this capture
            </summary>
        </member>
        <member name="M:Emgu.CV.Capture.GetCaptureProperty(Emgu.CV.CvEnum.CAP_PROP)">
            <summary>
            Obtain the capture property
            </summary>
            <param name="index">The index for the property</param>
            <returns>The value of the specific property</returns>
        </member>
        <member name="M:Emgu.CV.Capture.QueryFrame">
            <summary> Capture a RGB image frame</summary>
            <returns> A RGB image frame</returns>
        </member>
        <member name="M:Emgu.CV.Capture.QuerySmallFrame">
            <summary> 
            Capture a RGB image frame that is half width and half heigh. 
            Internally, this is a cvQueryFrame operation follow by a cvPyrDown
            </summary>
            <returns> A RGB image frame that is half width and half height</returns>
        </member>
        <member name="M:Emgu.CV.Capture.DuplexQueryFrame">
            <summary>
            Query a frame duplexly over WCF
            </summary>
        </member>
        <member name="M:Emgu.CV.Capture.DuplexQuerySmallFrame">
            <summary>
            Query a small frame duplexly over WCF
            </summary>
        </member>
        <member name="M:Emgu.CV.Capture.QueryTimedFrame">
            <summary> Capture Bgr image frame with timestamp</summary>
            <returns> A timestamped Bgr image frame</returns>
        </member>
        <member name="P:Emgu.CV.Capture.Width">
            <summary> The width of this capture</summary>
        </member>
        <member name="P:Emgu.CV.Capture.Height">
            <summary> The height of this capture </summary>
        </member>
        <member name="T:Emgu.CV.MIplImage">
            <summary>
            Managed structure equivalent to IplImage
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.nSize">
            <summary>
            sizeof(IplImage) 
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.ID">
            <summary>
            version (=0)
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.nChannels">
            <summary>
            Most of OpenCV functions support 1,2,3 or 4 channels 
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.alphaChannel">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.depth">
            <summary>
            pixel depth in bits: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16U, IPL_DEPTH_16S, IPL_DEPTH_32S, IPL_DEPTH_32F and IPL_DEPTH_64F are supported 
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.colorModel">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.channelSeq">
            <summary>
            ditto
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.dataOrder">
            <summary>
            0 - interleaved color channels, 1 - separate color channels.
            cvCreateImage can only create interleaved images 
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.origin">
            <summary>
            0 - top-left origin,
            1 - bottom-left origin (Windows bitmaps style)
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.align">
            <summary>
            Alignment of image rows (4 or 8).
            OpenCV ignores it and uses widthStep instead 
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.width">
            <summary>
            image width in pixels 
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.height">
            <summary>
            image height in pixels 
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.roi">
            <summary>
            image ROI. when it is not NULL, this specifies image region to process 
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.maskROI">
            <summary>
            must be NULL in OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.imageId">
            <summary>
            ditto
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.tileInfo">
            <summary>
            ditto 
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.imageSize">
            <summary>
            image data size in bytes
            (=image->height*image->widthStep in case of interleaved data)
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.imageData">
            <summary>
            pointer to aligned image data 
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.widthStep">
            <summary>
            size of aligned image row in bytes 
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.BorderMode">
            <summary>
            border completion mode, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.BorderConst">
            <summary>
            ditto
            </summary>
        </member>
        <member name="F:Emgu.CV.MIplImage.imageDataOrigin">
            <summary>
             pointer to a very origin of image data (not necessarily aligned) - it is needed for correct image deallocation 
            </summary>
        </member>
        <member name="T:Emgu.CV.IplImageOffset">
            <summary>
            Offset in bytes for different fields of IplImage
            </summary>
        </member>
        <member name="F:Emgu.CV.IplImageOffset.nSize">
            <summary>
            offset of nSize
            </summary>
        </member>
        <member name="F:Emgu.CV.IplImageOffset.ID">
            <summary>
            Offset of ID
            </summary>
        </member>
        <member name="F:Emgu.CV.IplImageOffset.nChannels">
            <summary>
            Offset of nchannels
            </summary>
        </member>
        <member name="F:Emgu.CV.IplImageOffset.alphaChannel">
            <summary>
            Offset of alpha Channel
            </summary>
        </member>
        <member name="F:Emgu.CV.IplImageOffset.depth">
            <summary>
            Offset of depth
            </summary>
        </member>
        <member name="F:Emgu.CV.IplImageOffset.colorModel">
            <summary>
            Offset of colorModel
            </summary>
        </member>
        <member name="F:Emgu.CV.IplImageOffset.channelSeq">
            <summary>
            Offset of channelSeq
            </summary>
        </member>
        <member name="F:Emgu.CV.IplImageOffset.dataOrder">
            <summary>
            Offset of dataOrder
            </summary>
        </member>
        <member name="F:Emgu.CV.IplImageOffset.origin">
            <summary>
            Offset of origin
            </summary>
        </member>
        <member name="F:Emgu.CV.IplImageOffset.align">
            <summary>
            Offset of align
            </summary>
        </member>
        <member name="F:Emgu.CV.IplImageOffset.width">
            <summary>
            Offset of width
            </summary>
        </member>
        <member name="F:Emgu.CV.IplImageOffset.height">
            <summary>
            Offset of height
            </summary>
        </member>
        <member name="F:Emgu.CV.IplImageOffset.roi">
            <summary>
            Offset of roi
            </summary>
        </member>
        <member name="T:Emgu.CV.UI.ImageViewer">
            <summary>
            The Image viewer that display IImage
            </summary>
        </member>
        <member name="M:Emgu.CV.UI.ImageViewer.#ctor(Emgu.CV.IImage)">
            <summary>
            Create a ImageViewer from the specific <paramref name="img"/>
            </summary>
            <param name="img">The image to be displayed in this viewer</param>
        </member>
        <member name="M:Emgu.CV.UI.ImageViewer.#ctor(Emgu.CV.IImage,System.String)">
            <summary>
            Create a ImageViewer from the specific <paramref name="img"/>, using <paramref name="windowName"/> as window name
            </summary>
            <param name="img">The image to be displayed</param>
            <param name="windowName">The name of the window</param>
        </member>
        <member name="F:Emgu.CV.UI.ImageViewer.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Emgu.CV.UI.ImageViewer.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Emgu.CV.UI.ImageViewer.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Emgu.CV.CameraCalibration.ExtrinsicCameraParameters">
            <summary>
            The extrinsic camera parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.ExtrinsicCameraParameters.#ctor">
            <summary>
            Create the extrinsic camera parameters
            </summary>
        </member>
        <member name="P:Emgu.CV.CameraCalibration.ExtrinsicCameraParameters.RotationVector">
            <summary>
            Get or Set the rodrigus rotation vector
            </summary>
        </member>
        <member name="P:Emgu.CV.CameraCalibration.ExtrinsicCameraParameters.TranslationVector">
            <summary>
            Get or Set the translation vector ( as 3 x 1 matrix)
            </summary>
        </member>
        <member name="T:Emgu.CV.MCvSize">
            <summary>
            Manager structure equivalent to CvSize
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSize.width">
            <summary>
            The width of the size
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSize.height">
            <summary>
            The height of the size
            </summary>
        </member>
        <member name="M:Emgu.CV.MCvSize.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new MCvSize using the specific width and height
            </summary>
            <param name="w">width</param>
            <param name="h">height</param>
        </member>
        <member name="T:Emgu.CV.MCvRect">
            <summary>
            Managed structure equivalent to CvRect
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvRect.x">
            <summary>
            x-coordinate of the left-most rectangle corner[s]
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvRect.y">
            <summary>
            y-coordinate of the bottom-most rectangle corner[s]
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvRect.width">
            <summary>
            width of the rectangle
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvRect.height">
            <summary>
            height of the rectangle 
            </summary>
        </member>
        <member name="M:Emgu.CV.MCvRect.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a CvRect with the specific information
            </summary>
            <param name="x">x-coordinate of the left-most rectangle corner[s]</param>
            <param name="y">y-coordinate of the bottom-most rectangle corner[s]</param>
            <param name="width">width of the rectangle</param>
            <param name="height">height of the rectangle </param>
        </member>
        <member name="P:Emgu.CV.MCvRect.Center">
            <summary>
            Center of the CvRect
            </summary>
        </member>
        <member name="P:Emgu.CV.MCvRect.Size">
            <summary>
            Size of the CvRect
            </summary>
        </member>
        <member name="T:Emgu.CV.LineSegment2D`1">
            <summary> A line segment </summary>
        </member>
        <member name="M:Emgu.CV.LineSegment2D`1.#ctor(Emgu.CV.Point2D{`0},Emgu.CV.Point2D{`0})">
            <summary> Create a line segment with the specific starting point and end point </summary>
        </member>
        <member name="P:Emgu.CV.LineSegment2D`1.Length">
            <summary> The length of the line segment </summary>
        </member>
        <member name="T:Emgu.CV.Histogram">
            <summary> 
             Class Histogram 
            </summary>
            <remarks><B>This is a Beta version</B></remarks>
        </member>
        <member name="M:Emgu.CV.Histogram.Clear">
            <summary> 
             Clear this histogram
            </summary>
        </member>
        <member name="M:Emgu.CV.Histogram.Accumulate``1(Emgu.CV.Image{Emgu.CV.Gray,``0}[])">
            <summary> 
             Project the image to the histogram bins 
            </summary>
        </member>
        <member name="M:Emgu.CV.Histogram.BackProject``1(Emgu.CV.Image{Emgu.CV.Gray,``0}[])">
            <summary> Back project the histogram into an gray scale image</summary>
        </member>
        <member name="M:Emgu.CV.Histogram.Threshold(System.Double)">
            <summary>
            Clears histogram bins that are below the specified threshold.
            </summary>
            <param name="thresh">The threshold used to clear the bins</param>
        </member>
        <member name="M:Emgu.CV.Histogram.Query(System.Int32[])">
            <summary> Retrieve item counts for the specific bin </summary>
        </member>
        <member name="M:Emgu.CV.Histogram.FreeUnmanagedObjects">
            <summary>
            Release the histogram and all memory associate with it
            </summary>
        </member>
        <member name="T:Emgu.CV.Contour">
            <summary>
            Wrapped class for Contour
            </summary>
        </member>
        <member name="M:Emgu.CV.Contour.#ctor(System.IntPtr,Emgu.CV.MemStorage)">
            <summary>
            Craete a contour from the specific IntPtr and storage
            </summary>
            <param name="ptr"></param>
            <param name="storage"></param>
        </member>
        <member name="T:Emgu.CV.Map`2">
            <summary>
            A Map is similar to an Image, except that the location of the pixels is defined by 
            its area and resolution
            </summary>
            <typeparam name="C">The color of this map</typeparam>
            <typeparam name="D">The depth of this map</typeparam>
        </member>
        <member name="M:Emgu.CV.Map`2.#ctor(Emgu.CV.Rectangle{System.Double},Emgu.CV.Point2D{System.Double},`0)">
            <summary>
            Create a new Image Map defined by the Rectangle area. The center (0.0, 0.0) of this map is 
            defined by the center of the rectangle.
            </summary>
            <param name="area"></param>
            <param name="resolution">The resolution of x (y), (e.g. a value of 0.5 means each cell in the map is 0.5 unit in x (y) dimension)</param>
            <param name="color"> The initial color of the map</param>
        </member>
        <member name="M:Emgu.CV.Map`2.#ctor(Emgu.CV.Rectangle{System.Double},Emgu.CV.Point2D{System.Double})">
            <summary>
            Create a new Image Map defined by the Rectangle area. The center (0.0, 0.0) of this map is 
            defined by the center of the rectangle. The initial value of the map is 0.0
            </summary>
            <param name="area"></param>
            <param name="resolution">The resolution of x (y), (e.g. a value of 0.5 means each cell in the map is 0.5 unit in x (y) dimension)</param>
        </member>
        <member name="M:Emgu.CV.Map`2.#ctor(Emgu.CV.Image{`0,`1},Emgu.CV.Rectangle{System.Double})">
            <summary>
            Create a new Map using the specific image and the rectangle area
            </summary>
            <param name="image">The image of this map</param>
            <param name="area">The area of this map</param>
        </member>
        <member name="M:Emgu.CV.Map`2.MapPoint``1(Emgu.CV.Point2D{``0})">
            <summary>
            Map a point to a position in the internal image
            </summary>
            <typeparam name="D2"></typeparam>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw``1(Emgu.CV.Rectangle{``0},`0,System.Int32)">
            <summary>
            Draw a rectangle in the map
            </summary>
            <typeparam name="T">The type of the rectangle</typeparam>
            <param name="rect">The rectangle to draw</param>
            <param name="color">The color for the rectangle</param>
            <param name="thickness">The thickness of the rectangle, any value less than or equal to 0 will result in a filled rectangle</param>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw``1(Emgu.CV.LineSegment2D{``0},`0,System.Int32)">
            <summary>
            Draw a line segment in the map
            </summary>
            <typeparam name="T">The type of the line</typeparam>
            <param name="line">The line to be draw</param>
            <param name="color">The color for the line</param>
            <param name="thickness">The thickness of the line</param>
        </member>
        <member name="M:Emgu.CV.Map`2.Convert``1(Emgu.Utils.Func{`1,System.Double,System.Double,``0})">
            <summary>
            Compute a new map where each element is obtained from converter
            </summary>
            <typeparam name="D2">The depth of the new Map</typeparam>
            <param name="converter">The converter that use the element from <i>this</i> map and the location of each pixel as input to compute the result</param>
            <returns> A new map where each element is obtained from converter</returns>
        </member>
        <member name="P:Emgu.CV.Map`2.Area">
            <summary>
            The area of this map as a rectangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Map`2.Resolution">
            <summary>
            The resolution of this map as a 2D point
            </summary>
        </member>
        <member name="T:Emgu.CV.Circle`1">
            <summary> A circle </summary>
        </member>
        <member name="M:Emgu.CV.Circle`1.#ctor">
            <summary> Create a circle with default values</summary>
        </member>
        <member name="M:Emgu.CV.Circle`1.#ctor(Emgu.CV.Point2D{`0},`0)">
            <summary> Create a circle with the specific center and radius </summary>
            <param name="center"> The center of this circle </param>
            <param name="radius"> The radius of this circle </param>
        </member>
        <member name="M:Emgu.CV.Circle`1.Equals(Emgu.CV.Circle{`0})">
            <summary>
            Compare this circle with <paramref name="circle2"/>
            </summary>
            <param name="circle2">The other box to be compared</param>
            <returns>true if the two boxes equals</returns>
        </member>
        <member name="P:Emgu.CV.Circle`1.Center">
            <summary> The center of the circle </summary>
        </member>
        <member name="P:Emgu.CV.Circle`1.Radius">
            <summary> The radius of the circle </summary>
        </member>
        <member name="P:Emgu.CV.Circle`1.Area">
            <summary> The area of the circle </summary>
        </member>
        <member name="T:Emgu.CV.MCvHistogram">
            <summary>
            Managed structure equivalent to CvMat
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvHistogram.type">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvHistogram.bins">
            <summary>
            Pointer to CvArr
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvHistogram.thresh">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvHistogram.thresh2">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvHistogram.mat">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.MCvBox2D">
            <summary>
            Managed structure equivalent to CvBox2D
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvBox2D.center">
            <summary>
            The center of the box
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvBox2D.size">
            <summary>
            The size of the box
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvBox2D.angle">
            <summary>
            The angle of the box
            </summary>
        </member>
        <member name="T:Emgu.CV.Hls">
            <summary> 
            Defines a Hls (Hue Lightness Satuation) color
            </summary>
        </member>
        <member name="M:Emgu.CV.Hls.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Hls color using the specific values</summary>
            <param name="hue"> The hue value for this color ( 0 &lt; hue &lt; 180 )  </param>
            <param name="satuation"> The satuation for this color </param>
            <param name="lightness"> The lightness for this color </param>
        </member>
        <member name="M:Emgu.CV.Hls.#ctor">
            <summary> Create a Hls color using the default values (0.0, 0.0, 0.0)</summary>
        </member>
        <member name="P:Emgu.CV.Hls.H">
            <summary> The intensity of the hue color channel ( 0 &lt; hue &lt; 180 ) </summary>
        </member>
        <member name="P:Emgu.CV.Hls.L">
            <summary> The intensity of the lightness color channel </summary>
        </member>
        <member name="P:Emgu.CV.Hls.S">
            <summary> The intensity of the satuation color channel </summary>
        </member>
        <member name="T:Emgu.CV.MCvMatND">
            <summary>
            Managed structure equivalent to CvMat
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMatND.type">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMatND.dims">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMatND.refcount">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMatND.hdr_refcount">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMatND.data">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvMatND.size">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CaptureClient">
            <summary>
            A Camera capture client that use DuplexCaptureCallback to request image from the server
            </summary>
        </member>
        <member name="M:Emgu.CV.CaptureClient.#ctor(System.ServiceModel.Channels.Binding,System.String)">
            <summary>
            Create a capture client with the specific binding and url
            </summary>
            <param name="binding">The binding for this client</param>
            <param name="url">The url of the server</param>
        </member>
        <member name="M:Emgu.CV.CaptureClient.Dispose">
            <summary>
            Dispose function
            </summary>
        </member>
        <member name="M:Emgu.CV.CaptureClient.Dispose(System.Boolean)">
            <summary> 
             Release the capture and all the memory associate with it
            </summary>
        </member>
        <member name="M:Emgu.CV.CaptureClient.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="T:Emgu.CV.Luv">
            <summary> 
            Defines a CIE Luv color 
            </summary>
        </member>
        <member name="M:Emgu.CV.Luv.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a CIE Lab color using the specific values</summary>
            <param name="z"> The z value for this color </param>
            <param name="y"> The y value for this color </param>
            <param name="x"> The x value for this color </param>
        </member>
        <member name="M:Emgu.CV.Luv.#ctor">
            <summary> Create a CIE Luv color using the default values (0.0, 0.0, 0.0)</summary>
        </member>
        <member name="P:Emgu.CV.Luv.X">
            <summary> The intensity of the z color channel </summary>
        </member>
        <member name="P:Emgu.CV.Luv.Y">
            <summary> The intensity of the y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Luv.Z">
            <summary> The intensity of the x color channel </summary>
        </member>
        <member name="T:Emgu.CV.Lab">
            <summary> 
            Defines a CIE Lab color 
            </summary>
        </member>
        <member name="M:Emgu.CV.Lab.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a CIE Lab color using the specific values</summary>
            <param name="z"> The z value for this color </param>
            <param name="y"> The y value for this color </param>
            <param name="x"> The x value for this color </param>
        </member>
        <member name="M:Emgu.CV.Lab.#ctor">
            <summary> Create a CIE Lab color using the default values (0.0, 0.0, 0.0)</summary>
        </member>
        <member name="P:Emgu.CV.Lab.X">
            <summary> The intensity of the z color channel </summary>
        </member>
        <member name="P:Emgu.CV.Lab.Y">
            <summary> The intensity of the y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Lab.Z">
            <summary> The intensity of the x color channel </summary>
        </member>
        <member name="T:Emgu.CV.Bgr">
            <summary> 
            Defines a Bgr (Blue Green Red) color
            </summary>
        </member>
        <member name="M:Emgu.CV.Bgr.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a RGB color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
        </member>
        <member name="M:Emgu.CV.Bgr.#ctor">
            <summary> Create a RGB color using the default values (0.0, 0.0, 0.0)</summary>
        </member>
        <member name="P:Emgu.CV.Bgr.B">
            <summary> The intensity of the z color channel </summary>
        </member>
        <member name="P:Emgu.CV.Bgr.G">
            <summary> The intensity of the y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Bgr.R">
            <summary> The intensity of the x color channel </summary>
        </member>
        <member name="T:Emgu.CV.MCvPoint2D32f">
            <summary>
            Managed Structure equivalent to CvPoint2D32f
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvPoint2D32f.x">
            <summary>
            x-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvPoint2D32f.y">
            <summary>
            y-coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.MCvPoint2D32f.#ctor(System.Single,System.Single)">
            <summary>
            Create a MCvPoint2D32f structure with the specific x and y coordinates
            </summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
        </member>
        <member name="T:Emgu.CV.MemStorage">
            <summary>
            Wrapper to the OpenCV MemStorage
            </summary>
        </member>
        <member name="M:Emgu.CV.MemStorage.#ctor">
            <summary>
            Create a OpenCV MemStorage
            </summary>
        </member>
        <member name="M:Emgu.CV.MemStorage.FreeUnmanagedObjects">
            <summary>
            Release the storage
            </summary>
        </member>
        <member name="T:Emgu.CV.ExposableMethodAttribute">
            <summary>
            Attribute used by ImageBox to generate Operation Menu
            </summary>
        </member>
        <member name="M:Emgu.CV.ExposableMethodAttribute.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Emgu.CV.ExposableMethodAttribute.Exposable">
            <summary>
            Get or Set the Exposable value, if true, this function will be displayed in Operation Menu of ImageBox
            </summary>
        </member>
    </members>
</doc>
